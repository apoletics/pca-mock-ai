[
    {
        "question": "Which PromQL function is used to calculate the ratio between two counters?",
        "options": {
            "A": "ratio()",
            "B": "div()",
            "C": "rate()",
            "D": "sum_ratio()"
        },
        "answer": "B"
    },
    {
        "question": "What is the default storage duration for metrics in Prometheus?",
        "options": {
            "A": "7 days",
            "B": "15 days",
            "C": "30 days",
            "D": "90 days"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the current temperature of a server?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the alertmanager_configs section in Prometheus configuration specify?",
        "options": {
            "A": "How metrics are stored",
            "B": "Where to send alerts",
            "C": "Which targets to scrape",
            "D": "How to aggregate metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which query would return the total number of HTTP 500 errors in the last hour?",
        "options": {
            "A": "sum(increase(http_requests_total{status=\"500\"}[1h]))",
            "B": "sum(http_requests_total{status=\"500\"})",
            "C": "rate(http_requests_total{status=\"500\"}[1h])",
            "D": "count(http_requests_total{status=\"500\"}[1h])"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the keep_firing_for parameter in an alert rule?",
        "options": {
            "A": "How long to wait before sending the first notification",
            "B": "How long to keep an alert in firing state after it's resolved",
            "C": "The minimum duration for which the condition must be true",
            "D": "How often to repeat notifications"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism is used for Docker containers?",
        "options": {
            "A": "kubernetes_sd_configs",
            "B": "docker_sd_configs",
            "C": "consul_sd_configs",
            "D": "file_sd_configs"
        },
        "answer": "B"
    },
    {
        "question": "What does the jitter parameter in Alertmanager configuration do?",
        "options": {
            "A": "Adds random delay to prevent thundering herd",
            "B": "Defines the maximum notification frequency",
            "C": "Sets the priority of alerts",
            "D": "Calculates the severity score of alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type automatically provides buckets for histogram calculations?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What is the effect of the action: keep in a relabel configuration?",
        "options": {
            "A": "Keeps only the targets matching the regex",
            "B": "Keeps all targets regardless of labels",
            "C": "Keeps the specified labels and drops others",
            "D": "Keeps the target configuration unchanged"
        },
        "answer": "A"
    },
    {
        "question": "Which query would find the top 3 services by error rate?",
        "options": {
            "A": "topk(3, sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (service) / sum(rate(http_requests_total[5m])) by (service))",
            "B": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (service) | top 3",
            "C": "top(3, rate(http_requests_total{status=~\"5..\"}[5m]) by (service))",
            "D": "max(rate(http_requests_total{status=~\"5..\"}[5m])) by (service) limit 3"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the Push Gateway?",
        "options": {
            "A": "To push alerts to external systems",
            "B": "To collect metrics from short-lived jobs",
            "C": "To push configuration changes to Prometheus",
            "D": "To gatekeep which metrics are stored"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter controls how often Prometheus evaluates alerting rules?",
        "options": {
            "A": "evaluation_interval",
            "B": "scrape_interval",
            "C": "alert_interval",
            "D": "rule_interval"
        },
        "answer": "A"
    },
    {
        "question": "What does the up metric indicate?",
        "options": {
            "A": "Whether Prometheus is running",
            "B": "The uptime of the Prometheus server",
            "C": "Whether a target is reachable",
            "D": "The CPU usage of targets"
        },
        "answer": "C"
    },
    {
        "question": "Which function would you use to calculate the 95th percentile from a histogram?",
        "options": {
            "A": "percentile(0.95, ...)",
            "B": "histogram_quantile(0.95, ...)",
            "C": "quantile(0.95, ...)",
            "D": "histogram_percentile(0.95, ...)"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of alert grouping in Alertmanager?",
        "options": {
            "A": "To group similar alerts into a single notification",
            "B": "To group alerts by severity",
            "C": "To group alerts by time of occurrence",
            "D": "To group alerts by the team responsible"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the number of requests over time?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the external_labels configuration in Prometheus do?",
        "options": {
            "A": "Labels applied to metrics scraped from external systems",
            "B": "Labels added to all metrics stored in Prometheus",
            "C": "Labels used for service discovery",
            "D": "Labels used for alert routing"
        },
        "answer": "B"
    },
    {
        "question": "Which query would show the percentage of memory used on a server?",
        "options": {
            "A": "(node_memory_used_bytes / node_memory_total_bytes) * 100",
            "B": "node_memory_used_bytes / node_memory_total_bytes * 100",
            "C": "percent(node_memory_used_bytes, node_memory_total_bytes)",
            "D": "rate(node_memory_used_bytes[5m]) / rate(node_memory_total_bytes[5m]) * 100"
        },
        "answer": "A"
    },
    {
        "question": "What is the default port on which Prometheus listens for HTTP requests?",
        "options": {
            "A": "8080",
            "B": "9090",
            "C": "9100",
            "D": "3000"
        },
        "answer": "B"
    },
    {
        "question": "Which Alertmanager parameter controls the time after which a resolved alert is no longer sent?",
        "options": {
            "A": "resolve_timeout",
            "B": "resolved_ttl",
            "C": "keep_resolved_for",
            "D": "notification_timeout"
        },
        "answer": "A"
    },
    {
        "question": "What does the __meta prefix indicate in Prometheus labels?",
        "options": {
            "A": "Metadata labels generated by service discovery",
            "B": "Internal labels used by Prometheus",
            "C": "Labels that should be preserved during relabeling",
            "D": "Deprecated labels that will be removed"
        },
        "answer": "A"
    },
    {
        "question": "Which function would you use to calculate the increase in a counter over a time range?",
        "options": {
            "A": "increase()",
            "B": "delta()",
            "C": "change()",
            "D": "grow()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of recording rules in Prometheus?",
        "options": {
            "A": "To record which targets are being scraped",
            "B": "To precompute and store frequently used expressions",
            "C": "To record alert history",
            "D": "To record configuration changes"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type should you use when you need quantiles calculated on the client side?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "D"
    },
    {
        "question": "What does the scrape_timeout parameter control?",
        "options": {
            "A": "How long to wait for a target to respond to a scrape",
            "B": "How long to keep scraped data",
            "C": "How often to scrape targets",
            "D": "How long to wait before marking a target as down"
        },
        "answer": "A"
    },
    {
        "question": "Which query would return the number of targets that are down?",
        "options": {
            "A": "count(up == 0)",
            "B": "sum(up == 0)",
            "C": "count(up{up=0})",
            "D": "sum by (job) (up == 0)"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the inhibit_rules in Alertmanager?",
        "options": {
            "A": "To prevent high-priority alerts from being sent",
            "B": "To suppress certain alerts when other alerts are firing",
            "C": "To delay notifications for low-severity alerts",
            "D": "To inhibit duplicate alerts from being generated"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism uses configuration files to define targets?",
        "options": {
            "A": "dns_sd_configs",
            "B": "file_sd_configs",
            "C": "static_configs",
            "D": "http_sd_configs"
        },
        "answer": "B"
    },
    {
        "question": "What does the rate() function calculate?",
        "options": {
            "A": "The total value of a counter over a time range",
            "B": "The average per-second rate of increase of a counter",
            "C": "The maximum value of a gauge over a time range",
            "D": "The ratio between two metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter in Prometheus configuration defines the storage location?",
        "options": {
            "A": "storage_path",
            "B": "data_dir",
            "C": "storage_root",
            "D": "db_path"
        },
        "answer": "A"
    },
    {
        "question": "Which query would you use to find the average request duration for all API endpoints?",
        "options": {
            "A": "avg(http_request_duration_seconds_sum / http_request_duration_seconds_count) by (endpoint)",
            "B": "avg(http_request_duration_seconds) by (endpoint)",
            "C": "mean(http_request_duration_seconds) by (endpoint)",
            "D": "average(rate(http_request_duration_seconds[5m])) by (endpoint)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the smap configuration in Alertmanager?",
        "options": {
            "A": "To map alerts to different notification channels",
            "B": "To map labels to annotations",
            "C": "To map severity levels to priority",
            "D": "To map alert names to descriptions"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the duration of user sessions?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the remote_write configuration in Prometheus allow?",
        "options": {
            "A": "Writing metrics to external storage systems",
            "B": "Writing configuration changes to disk",
            "C": "Writing alerts to Alertmanager",
            "D": "Writing logs to a central system"
        },
        "answer": "A"
    },
    {
        "question": "Which function would you use to calculate the difference between the current and previous value of a gauge?",
        "options": {
            "A": "diff()",
            "B": "delta()",
            "C": "change()",
            "D": "var()"
        },
        "answer": "B"
    },
    {
        "question": "What is the default interval at which Prometheus scrapes targets?",
        "options": {
            "A": "10s",
            "B": "15s",
            "C": "30s",
            "D": "60s"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter in an alert rule defines how long the condition must be true before firing?",
        "options": {
            "A": "for",
            "B": "wait",
            "C": "delay",
            "D": "duration"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the honor_labels configuration in a scrape job?",
        "options": {
            "A": "To preserve labels from the target rather than overwriting them",
            "B": "To ensure all metrics have required labels",
            "C": "To honor label confidentiality requirements",
            "D": "To automatically add honor-related labels"
        },
        "answer": "A"
    },
    {
        "question": "Which query would you use to find the number of unique jobs being scraped?",
        "options": {
            "A": "count(count by (job) (up))",
            "B": "unique_count(up) by (job)",
            "C": "count by (job) (up)",
            "D": "count_values(\"job\", up)"
        },
        "answer": "A"
    },
    {
        "question": "What is the main purpose of Alertmanager?",
        "options": {
            "A": "To scrape metrics from targets",
            "B": "To manage and route alerts",
            "C": "To store long-term metrics",
            "D": "To visualize metrics data"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type is monotonic and only increases?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the retention_size configuration parameter control?",
        "options": {
            "A": "The maximum number of metrics to retain",
            "B": "The maximum size of the storage directory",
            "C": "The number of days to retain metrics",
            "D": "The size of each block in the storage"
        },
        "answer": "B"
    },
    {
        "question": "Which query would show the total number of requests per endpoint in the last 5 minutes?",
        "options": {
            "A": "sum(increase(http_requests_total[5m])) by (endpoint)",
            "B": "sum(http_requests_total) by (endpoint)",
            "C": "rate(http_requests_total[5m]) by (endpoint)",
            "D": "count(http_requests_total{endpoint=~\"/.+\"}[5m])"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the repeat_interval in Alertmanager?",
        "options": {
            "A": "How often to repeat notifications for firing alerts",
            "B": "How often to check for new alerts",
            "C": "How often to repeat the same alert to different receivers",
            "D": "How often to clear resolved alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses DNS SRV records to find targets?",
        "options": {
            "A": "dns_sd_configs",
            "B": "srv_sd_configs",
            "C": "dns_records_sd_configs",
            "D": "service_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which function would you use to calculate the sum of metrics across all instances?",
        "options": {
            "A": "total()",
            "B": "sum()",
            "C": "aggregate()",
            "D": "collect()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the rule_files configuration in Prometheus?",
        "options": {
            "A": "To specify where to store alerting rules",
            "B": "To define which files contain recording and alerting rules",
            "C": "To specify the rules for service discovery",
            "D": "To define retention rules for metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type would you use to track both the count and sum of request durations?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Both Histogram and Summary"
        },
        "answer": "D"
    },
    {
        "question": "What does the remote_read configuration in Prometheus allow?",
        "options": {
            "A": "Reading metrics from external storage systems",
            "B": "Reading configuration from remote servers",
            "C": "Reading alert status from Alertmanager",
            "D": "Reading logs from remote systems"
        },
        "answer": "A"
    },
    {
        "question": "Which query would you use to find the maximum CPU usage across all servers?",
        "options": {
            "A": "max(node_cpu_usage_percentage) by (instance)",
            "B": "max_over_time(node_cpu_usage_percentage[5m])",
            "C": "max(node_cpu_usage_percentage)",
            "D": "maximum(node_cpu_usage_percentage) by (instance)"
        },
        "answer": "C"
    },
    {
        "question": "What is the default port for the Node Exporter?",
        "options": {
            "A": "8080",
            "B": "9090",
            "C": "9100",
            "D": "9200"
        },
        "answer": "C"
    },
    {
        "question": "Which Alertmanager parameter controls the time to wait for additional alerts in the same group before sending a notification?",
        "options": {
            "A": "group_wait",
            "B": "group_interval",
            "C": "wait_for_more",
            "D": "notification_delay"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of the action: labeldrop in a relabel configuration?",
        "options": {
            "A": "Drops the target if it has the specified labels",
            "B": "Drops the specified labels from the target",
            "C": "Drops all labels except the specified ones",
            "D": "Drops labels that match the regex pattern"
        },
        "answer": "B"
    },
    {
        "question": "Which function would you use to calculate the number of unique values for a label?",
        "options": {
            "A": "unique_count()",
            "B": "count_values()",
            "C": "label_count()",
            "D": "distinct()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the wal_truncate_duration configuration parameter?",
        "options": {
            "A": "How long to retain write-ahead log files",
            "B": "How often to truncate the write-ahead log",
            "C": "The duration after which the WAL is truncated during startup",
            "D": "The maximum size of the write-ahead log"
        },
        "answer": "C"
    },
    {
        "question": "Which query would show the 5-minute moving average of request rates?",
        "options": {
            "A": "avg_over_time(rate(http_requests_total[1m])[5m:])",
            "B": "rate(http_requests_total[5m])",
            "C": "moving_avg(rate(http_requests_total[1m]), 5m)",
            "D": "average(rate(http_requests_total[5m]))"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the resolve_timeout parameter in Alertmanager?",
        "options": {
            "A": "How long to wait before sending a resolved notification",
            "B": "How long to keep an alert in memory after it's resolved",
            "C": "The time after which an alert is considered resolved if no updates are received",
            "D": "How long to wait for a notification to be acknowledged"
        },
        "answer": "C"
    },
    {
        "question": "Which service discovery mechanism is used for AWS EC2 instances?",
        "options": {
            "A": "aws_sd_configs",
            "B": "ec2_sd_configs",
            "C": "cloud_sd_configs",
            "D": "aws_ec2_sd_configs"
        },
        "answer": "B"
    },
    {
        "question": "Which function would you use to calculate the minimum value of a metric over a time range?",
        "options": {
            "A": "min()",
            "B": "min_over_time()",
            "C": "minimum()",
            "D": "range_min()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the alert_relabel_configs in Prometheus?",
        "options": {
            "A": "To relabel alerts before sending them to Alertmanager",
            "B": "To relabel metrics used in alerting rules",
            "C": "To relabel targets that generate alerts",
            "D": "To relabel alerting rules themselves"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type would you use to track the current number of active users?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the tsdb section in Prometheus configuration control?",
        "options": {
            "A": "The time series database settings",
            "B": "The target scraping configuration",
            "C": "The alerting rule evaluation",
            "D": "The remote storage integration"
        },
        "answer": "A"
    },
    {
        "question": "Which query would you use to find the percentage of requests that resulted in errors?",
        "options": {
            "A": "(sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))) * 100",
            "B": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))",
            "C": "error_ratio(http_requests_total) * 100",
            "D": "count(http_requests_total{status=~\"5..\"}) / count(http_requests_total) * 100"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the group_interval parameter in Alertmanager?",
        "options": {
            "A": "The interval between notifications for the same alert group",
            "B": "The time to wait before creating a new alert group",
            "C": "The interval at which to check for new alerts to group",
            "D": "The minimum interval between group evaluations"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function estimates the future value of a gauge based on linear regression?",
        "options": {
            "A": "predict_linear()",
            "B": "forecast()",
            "C": "linear_estimate()",
            "D": "trend()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the block_duration configuration in Prometheus TSDB?",
        "options": {
            "A": "How long to retain each block of data",
            "B": "The time range covered by each data block",
            "C": "How often to create a new block",
            "D": "The maximum size of each block"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type should you use to track the number of failed login attempts?",
        "options": {
            "A": "Gauge",
            "B": "Counter",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the route section in Alertmanager configuration define?",
        "options": {
            "A": "The network route to send alerts",
            "B": "The hierarchy of alert routing to receivers",
            "C": "The path for webhook notifications",
            "D": "The route to Prometheus server"
        },
        "answer": "B"
    },
    {
        "question": "Which query calculates the per-second error rate for each service over the last 10 minutes?",
        "options": {
            "A": "sum(rate(http_requests_total{status=~\"5..\"}[10m])) by (service)",
            "B": "rate(http_requests_total{status=~\"5..\"}[10m]) by (service)",
            "C": "sum(http_requests_total{status=~\"5..\"}) by (service) / 600",
            "D": "increase(http_requests_total{status=~\"5..\"}[10m]) by (service) / 600"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of setting send_resolved: false in Alertmanager receiver configuration?",
        "options": {
            "A": "Prevents sending notifications when alerts are resolved",
            "B": "Stops sending new alerts once they're resolved",
            "C": "Sends resolved notifications only to secondary receivers",
            "D": "Delays resolved notifications by the repeat interval"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for Azure virtual machines?",
        "options": {
            "A": "azure_sd_configs",
            "B": "azure_vm_sd_configs",
            "C": "cloud_sd_configs",
            "D": "azure_resource_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "What does the deriv() function calculate?",
        "options": {
            "A": "The derivative of a gauge over time",
            "B": "The difference between two counter values",
            "C": "The rate of change of a histogram",
            "D": "The average value of a summary"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of samples that can be queried at once?",
        "options": {
            "A": "query.max_samples",
            "B": "max_query_samples",
            "C": "query.sample_limit",
            "D": "sample_query_limit"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of metric_relabel_configs in a scrape configuration?",
        "options": {
            "A": "To relabel targets before scraping",
            "B": "To modify labels on metrics after scraping",
            "C": "To relabel alerts generated from metrics",
            "D": "To configure labels for service discovery"
        },
        "answer": "B"
    },
    {
        "question": "Which query finds the number of instances where CPU usage exceeds 80%?",
        "options": {
            "A": "count(node_cpu_usage_percentage > 80)",
            "B": "count(node_cpu_usage_percentage{value>80})",
            "C": "count({name=~\"node_cpu_usage_percentage\", value>80})",
            "D": "sum(node_cpu_usage_percentage > 80) by (instance)"
        },
        "answer": "A"
    },
    {
        "question": "What is the default retention size for Prometheus storage?",
        "options": {
            "A": "50GB",
            "B": "100GB",
            "C": "No default limit",
            "D": "200GB"
        },
        "answer": "C"
    },
    {
        "question": "Which Alertmanager configuration defines who receives notifications?",
        "options": {
            "A": "receivers",
            "B": "notifiers",
            "C": "recipients",
            "D": "contacts"
        },
        "answer": "A"
    },
    {
        "question": "What does the __address__ label represent in Prometheus target labels?",
        "options": {
            "A": "The address of the Prometheus server",
            "B": "The address:port of the target being scraped",
            "C": "The IP address of the target's host",
            "D": "The URL path for scraping metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which function calculates the difference between the last two samples of a gauge?",
        "options": {
            "A": "delta()",
            "B": "idelta()",
            "C": "diff()",
            "D": "last_delta()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of annotations in an alerting rule?",
        "options": {
            "A": "To add metadata for alert routing",
            "B": "To provide descriptive information about the alert",
            "C": "To define the alert severity",
            "D": "To specify which receiver gets the alert"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type would you use to track the size of files being processed?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the query.lookback-delta configuration parameter control?",
        "options": {
            "A": "The maximum time to look back for missing samples",
            "B": "The time range for rate() calculations",
            "C": "How far back to query historical data",
            "D": "The delta between consecutive scrapes"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the 5-minute error rate ratio for each endpoint?",
        "options": {
            "A": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (endpoint) / sum(rate(http_requests_total[5m])) by (endpoint)",
            "B": "rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) by (endpoint)",
            "C": "sum(http_requests_total{status=~\"5..\"}) by (endpoint) / sum(http_requests_total) by (endpoint)",
            "D": "increase(http_requests_total{status=~\"5..\"}[5m]) by (endpoint) / 300"
        },
        "answer": "A"
    },
    {
        "question": "What is the default port for the Blackbox Exporter?",
        "options": {
            "A": "9115",
            "B": "9100",
            "C": "9090",
            "D": "9211"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager parameter defines the root route for alert routing?",
        "options": {
            "A": "root_route",
            "B": "route",
            "C": "default_route",
            "D": "primary_route"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of action: replace in a relabel configuration?",
        "options": {
            "A": "Replaces the target with a new one",
            "B": "Replaces the value of a label based on a regex",
            "C": "Replaces all labels with new ones",
            "D": "Replaces the scrape URL for the target"
        },
        "answer": "B"
    },
    {
        "question": "Which function calculates the standard deviation of a metric over a time range?",
        "options": {
            "A": "stddev()",
            "B": "stddev_over_time()",
            "C": "variance()",
            "D": "dev_over_time()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of write_relabel_configs in Prometheus?",
        "options": {
            "A": "To relabel metrics before writing to storage",
            "B": "To relabel targets before scraping",
            "C": "To relabel alerts before sending to Alertmanager",
            "D": "To relabel metrics before remote_write"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the current number of pending tasks in a queue?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the storage.tsdb.retention.time configuration override?",
        "options": {
            "A": "The default block duration",
            "B": "The default metric retention period",
            "C": "The maximum storage size",
            "D": "The WAL truncation duration"
        },
        "answer": "B"
    },
    {
        "question": "Which query finds the 75th percentile of response times for successful requests?",
        "options": {
            "A": "histogram_quantile(0.75, sum(rate(http_request_duration_seconds_bucket{status=~\"2..\"}[5m])) by (le))",
            "B": "quantile(0.75, http_request_duration_seconds{status=~\"2..\"})",
            "C": "sum(histogram_quantile(0.75, http_request_duration_seconds_bucket{status=~\"2..\"}))[5m]",
            "D": "rate(histogram_quantile(0.75, http_request_duration_seconds_bucket{status=~\"2..\"})[5m])"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of mute_time_intervals in Alertmanager?",
        "options": {
            "A": "Time intervals during which alerts are muted",
            "B": "Intervals between notification repeats",
            "C": "Time intervals for which alerts are kept in memory",
            "D": "Intervals for evaluating inhibit rules"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Consul to find targets?",
        "options": {
            "A": "consul_sd_configs",
            "B": "service_sd_configs",
            "C": "discovery_sd_configs",
            "D": "consul_service_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which function calculates the number of samples in a time range?",
        "options": {
            "A": "count_samples()",
            "B": "sample_count()",
            "C": "count_over_time()",
            "D": "num_samples()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of labels in an alerting rule?",
        "options": {
            "A": "To provide descriptive information about the alert",
            "B": "To define routing and grouping for the alert",
            "C": "To specify the severity of the alert",
            "D": "To list the instances affected by the alert"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type automatically includes a _count and _sum suffix?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Both Histogram and Summary"
        },
        "answer": "D"
    },
    {
        "question": "What does the remote_timeout configuration parameter control?",
        "options": {
            "A": "Timeout for remote_write and remote_read operations",
            "B": "Timeout for scraping remote targets",
            "C": "Timeout for Alertmanager notifications",
            "D": "Timeout for querying remote Prometheus servers"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the average number of requests per instance over the last hour?",
        "options": {
            "A": "avg(rate(http_requests_total[1h])) by (instance)",
            "B": "rate(avg(http_requests_total)[1h]) by (instance)",
            "C": "sum(rate(http_requests_total[1h])) / count(instance)",
            "D": "avg_over_time(http_requests_total[1h]) by (instance)"
        },
        "answer": "A"
    },
    {
        "question": "What is the default evaluation interval for alerting rules?",
        "options": {
            "A": "Same as scrape_interval",
            "B": "1 minute",
            "C": "30 seconds",
            "D": "5 minutes"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager receiver type sends notifications via email?",
        "options": {
            "A": "email_configs",
            "B": "smtp_configs",
            "C": "mail_configs",
            "D": "notification_email_configs"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of action: hashmod in a relabel configuration?",
        "options": {
            "A": "Hashes the target address for load balancing",
            "B": "Modifies the label value using a hash function",
            "C": "Distributes targets across scrape groups using a hash",
            "D": "Hashes sensitive labels for security"
        },
        "answer": "C"
    },
    {
        "question": "Which function calculates the exponential moving average over a time range?",
        "options": {
            "A": "ema()",
            "B": "exp_avg_over_time()",
            "C": "exponential_avg()",
            "D": "No built-in function for this"
        },
        "answer": "D"
    },
    {
        "question": "What is the purpose of the query_log_file configuration?",
        "options": {
            "A": "To log all PromQL queries executed",
            "B": "To log the results of queries",
            "C": "To log slow queries",
            "D": "To log query errors"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the number of bytes transferred over a network?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the tsdb.min-block-duration configuration control?",
        "options": {
            "A": "The minimum time a block can exist before being compacted",
            "B": "The smallest block size allowed",
            "C": "The minimum duration for which metrics are stored",
            "D": "The minimum interval between block creations"
        },
        "answer": "A"
    },
    {
        "question": "Which query finds instances where memory usage has increased by more than 20% in the last hour?",
        "options": {
            "A": "delta(node_memory_used_bytes[1h]) / node_memory_used_bytes offset 1h > 0.2",
            "B": "rate(node_memory_used_bytes[1h]) > 0.2",
            "C": "(node_memory_used_bytes - (node_memory_used_bytes offset 1h)) / (node_memory_used_bytes offset 1h) > 0.2",
            "D": "increase(node_memory_used_bytes[1h]) > 0.2 * node_memory_used_bytes"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of resolve_timeout in an Alertmanager route?",
        "options": {
            "A": "Overrides the global resolve_timeout for this route",
            "B": "Sets the timeout for resolving the route",
            "C": "Defines how long to wait for a response from the receiver",
            "D": "Specifies the timeout for alert grouping"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for Google Cloud Platform instances?",
        "options": {
            "A": "gcp_sd_configs",
            "B": "google_sd_configs",
            "C": "gce_sd_configs",
            "D": "cloud_gcp_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which function calculates the median value of a metric over a time range?",
        "options": {
            "A": "median()",
            "B": "median_over_time()",
            "C": "quantile(0.5, ...)",
            "D": "middle_over_time()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of alertmanager.timeout in Prometheus configuration?",
        "options": {
            "A": "Timeout for sending alerts to Alertmanager",
            "B": "Timeout for receiving responses from Alertmanager",
            "C": "Timeout for Alertmanager health checks",
            "D": "Maximum time to wait for Alertmanager to start"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type would you use to track the latency of database queries with predefined buckets?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the scrape_configs.job_name parameter define?",
        "options": {
            "A": "The name of the Prometheus job",
            "B": "The label value for the job label on scraped metrics",
            "C": "The name of the process running the scrape",
            "D": "The name used for logging scrape activities"
        },
        "answer": "B"
    },
    {
        "question": "Which query calculates the 99th percentile of request latency for each service?",
        "options": {
            "A": "histogram_quantile(0.99, sum(rate(http_request_duration_seconds_bucket[5m])) by (service, le))",
            "B": "histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m])) by (service)",
            "C": "quantile(0.99, sum(rate(http_request_duration_seconds[5m])) by (service))",
            "D": "sum(histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))) by (service)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of matchers in an Alertmanager route?",
        "options": {
            "A": "To match alerts to the route based on labels",
            "B": "To match receivers to alerts",
            "C": "To match time intervals for muting",
            "D": "To match alert severity levels"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of concurrent scrapes?",
        "options": {
            "A": "scrape.max_concurrent",
            "B": "max_concurrent_scrapes",
            "C": "concurrent_scrape_limit",
            "D": "scrape.concurrent_limit"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of action: labelmap in a relabel configuration?",
        "options": {
            "A": "Maps all labels to new names using a regex",
            "B": "Creates a new label with values from existing labels",
            "C": "Maps target addresses to label values",
            "D": "Maps service discovery metadata to labels"
        },
        "answer": "A"
    },
    {
        "question": "Which function predicts when a gauge will reach a threshold based on current trends?",
        "options": {
            "A": "predict_linear()",
            "B": "threshold_linear()",
            "C": "trend_estimate()",
            "D": "forecast_threshold()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the rule_files configuration in Alertmanager?",
        "options": {
            "A": "There is no such configuration in Alertmanager",
            "B": "To define alerting rules",
            "C": "To define routing rules",
            "D": "To define inhibition rules"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the number of user registrations per minute?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the storage.tsdb.wal-compression configuration do?",
        "options": {
            "A": "Compresses the write-ahead log to save space",
            "B": "Compresses old blocks in the TSDB",
            "C": "Enables compression for remote_write",
            "D": "Compresses metric labels during storage"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the percentage of available disk space on each node?",
        "options": {
            "A": "(node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100",
            "B": "node_filesystem_avail_bytes / node_filesystem_size_bytes * 100",
            "C": "percent_available(node_filesystem_avail_bytes, node_filesystem_size_bytes)",
            "D": "100 - (node_filesystem_used_bytes / node_filesystem_size_bytes * 100)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of group_by in an Alertmanager route?",
        "options": {
            "A": "Groups alerts by specified labels for notification",
            "B": "Groups routes by receiver",
            "C": "Groups alerts by severity",
            "D": "Groups alerts by time of firing"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses HTTP endpoints to discover targets?",
        "options": {
            "A": "http_sd_configs",
            "B": "api_sd_configs",
            "C": "web_sd_configs",
            "D": "endpoint_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which function calculates the sum of squares of a metric over a time range?",
        "options": {
            "A": "sum_squares()",
            "B": "squares_sum_over_time()",
            "C": "sum2_over_time()",
            "D": "sum_sq_over_time()"
        },
        "answer": "D"
    },
    {
        "question": "Which PromQL function returns a time series where each value is the count of how many times each label value occurs?",
        "options": {
            "A": "count_by()",
            "B": "count_values()",
            "C": "label_count()",
            "D": "value_counts()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the external_labels configuration in Prometheus when using federation?",
        "options": {
            "A": "To label metrics exported to other Prometheus servers",
            "B": "To filter external metrics during scraping",
            "C": "To identify external targets in service discovery",
            "D": "To restrict access to external metrics"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the duration of API requests with dynamic quantiles calculated on the server side?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the templates configuration in Alertmanager specify?",
        "options": {
            "A": "Files containing custom notification templates",
            "B": "Templates for alert labels and annotations",
            "C": "Templates for service discovery configurations",
            "D": "Templates for PromQL queries in alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the total number of 4xx errors in the last 30 minutes, excluding 404 errors?",
        "options": {
            "A": "sum(increase(http_requests_total{status=~\"4..\", status!=\"404\"}[30m]))",
            "B": "sum(http_requests_total{status=~\"4..\", status!=\"404\"})",
            "C": "rate(http_requests_total{status=~\"4..\", status!=\"404\"}[30m])",
            "D": "count(http_requests_total{status=~\"4..\", status!=\"404\"}[30m])"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of setting honor_timestamps: true in a scrape configuration?",
        "options": {
            "A": "Uses the timestamps provided by the target instead of Prometheus's scrape time",
            "B": "Preserves the original timestamps of metrics when storing them",
            "C": "Honors the timestamp labels on metrics during relabeling",
            "D": "Synchronizes scrape times with the target's clock"
        },
        "answer": "A"
    },
    {
        "question": "In Kubernetes service discovery, which role discovers pod targets?",
        "options": {
            "A": "endpoints",
            "B": "pods",
            "C": "services",
            "D": "nodes"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the average value of a metric over a specified time range?",
        "options": {
            "A": "avg()",
            "B": "mean()",
            "C": "avg_over_time()",
            "D": "average()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the storage.tsdb.max-block-duration configuration?",
        "options": {
            "A": "The maximum time a block can cover before compaction",
            "B": "The maximum duration a block can be stored",
            "C": "The maximum time to wait for block compaction",
            "D": "The maximum size of a single TSDB block"
        },
        "answer": "A"
    },
    {
        "question": "What does the action: keep_drop do in a relabel configuration?",
        "options": {
            "A": "Keeps or drops targets based on a regex match",
            "B": "This is not a valid relabel action",
            "C": "Keeps specified labels and drops all others",
            "D": "Drops targets that match the regex and keeps others"
        },
        "answer": "B"
    },
    {
        "question": "Which query identifies instances where the error rate has increased by more than 50% compared to the previous hour?",
        "options": {
            "A": "rate(http_requests_total{status=~\"5..\"}[1h]) > 1.5 * rate(http_requests_total{status=~\"5..\"}[1h] offset 1h)",
            "B": "increase(http_requests_total{status=~\"5..\"}[1h]) > 0.5 * increase(http_requests_total{status=~\"5..\"}[1h] offset 1h)",
            "C": "sum(rate(http_requests_total{status=~\"5..\"}[1h])) > 1.5 * sum(rate(http_requests_total{status=~\"5..\"}[1h] offset 1h))",
            "D": "rate(http_requests_total{status=~\"5..\"}[1h]) - rate(http_requests_total{status=~\"5..\"}[1h] offset 1h) > 0.5"
        },
        "answer": "A"
    },
    {
        "question": "What is the default port for the MySQL Server Exporter?",
        "options": {
            "A": "9104",
            "B": "9113",
            "C": "9121",
            "D": "9134"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager configuration defines conditions for suppressing alerts?",
        "options": {
            "A": "inhibit_rules",
            "B": "suppress_rules",
            "C": "mute_rules",
            "D": "block_rules"
        },
        "answer": "A"
    },
    {
        "question": "What does the __metrics_path__ label control in a target's labels?",
        "options": {
            "A": "The path where Prometheus stores the metrics",
            "B": "The HTTP path on the target where metrics are exposed",
            "C": "The path to the relabel configuration file",
            "D": "The path to the service discovery configuration"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the sum of all values in a time range for a metric?",
        "options": {
            "A": "sum()",
            "B": "sum_over_time()",
            "C": "total()",
            "D": "sum_range()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of annotations.summary in an alerting rule?",
        "options": {
            "A": "A brief description of the alert",
            "B": "A summary of all labels on the alert",
            "C": "A statistical summary of the metric triggering the alert",
            "D": "A summary of previous occurrences of the alert"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type would you use to track the current number of database connections?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the remote_write.batch_send_deadline configuration parameter control?",
        "options": {
            "A": "The maximum time to wait before sending a batch of metrics",
            "B": "The deadline for receiving confirmation of sent metrics",
            "C": "The maximum size of a remote_write batch",
            "D": "The interval between remote_write batches"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the ratio of 5xx errors to total requests for each service?",
        "options": {
            "A": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (service) / sum(rate(http_requests_total[5m])) by (service)",
            "B": "rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) by (service)",
            "C": "sum(http_requests_total{status=~\"5..\"}) by (service) / sum(http_requests_total) by (service)",
            "D": "increase(http_requests_total{status=~\"5..\"}[5m]) by (service) / increase(http_requests_total[5m]) by (service)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the queue_config in Alertmanager's receiver configuration?",
        "options": {
            "A": "Configures the queue for storing pending notifications",
            "B": "Defines the queue of receivers for alert routing",
            "C": "Sets the queue size for service discovery",
            "D": "Configures the retry queue for failed scrapes"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses DNS A records to discover targets?",
        "options": {
            "A": "dns_sd_configs with type 'A'",
            "B": "a_record_sd_configs",
            "C": "dns_a_sd_configs",
            "D": "dns_record_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the variance of a metric over a time range?",
        "options": {
            "A": "variance()",
            "B": "var()",
            "C": "var_over_time()",
            "D": "variance_over_time()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the scrape_configs.params configuration?",
        "options": {
            "A": "URL query parameters to send with scrape requests",
            "B": "Parameters for relabeling configurations",
            "C": "Parameters for service discovery filters",
            "D": "Parameters for metric aggregation"
        },
        "answer": "A"
    },
    {
        "question": "Which query identifies services where the 95th percentile latency exceeds 500ms?",
        "options": {
            "A": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (service, le)) > 0.5",
            "B": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) by (service) > 0.5",
            "C": "quantile(0.95, http_request_duration_seconds) by (service) > 0.5",
            "D": "sum(histogram_quantile(0.95, http_request_duration_seconds_bucket[5m])) by (service) > 0.5"
        },
        "answer": "A"
    },
    {
        "question": "What is the default size of the Alertmanager notification queue?",
        "options": {
            "A": "1000",
            "B": "10000",
            "C": "5000",
            "D": "50000"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type includes a _bucket suffix for cumulative counts?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the storage.tsdb.wal-segment-size configuration control?",
        "options": {
            "A": "The size of each write-ahead log segment",
            "B": "The total size of the write-ahead log",
            "C": "The size of the TSDB segments after WAL compaction",
            "D": "The size of the segment used for remote storage"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the 10-minute moving average of CPU usage for each instance?",
        "options": {
            "A": "avg_over_time(node_cpu_usage_percentage[10m:1m]) by (instance)",
            "B": "moving_avg(node_cpu_usage_percentage[10m]) by (instance)",
            "C": "avg(node_cpu_usage_percentage[10m]) by (instance)",
            "D": "mean_over_time(node_cpu_usage_percentage[10m]) by (instance)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of match in an Alertmanager inhibit rule?",
        "options": {
            "A": "Labels that the inhibited alert must have",
            "B": "Labels that the inhibiting alert must have",
            "C": "Labels that both alerts must share",
            "D": "Labels used to group inhibited alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for DigitalOcean Droplets?",
        "options": {
            "A": "digitalocean_sd_configs",
            "B": "do_sd_configs",
            "C": "droplet_sd_configs",
            "D": "cloud_digitalocean_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the number of distinct label values across time series?",
        "options": {
            "A": "distinct_count()",
            "B": "count(count by (label) (metric))",
            "C": "unique_count()",
            "D": "label_distinct()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of alertmanager.path_prefix in Prometheus configuration?",
        "options": {
            "A": "The URL path prefix for Alertmanager API requests",
            "B": "The file system path to Alertmanager configuration",
            "C": "The prefix for alert names sent to Alertmanager",
            "D": "The path prefix for Alertmanager web interface"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the number of bytes processed by a batch job?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the query.max_concurrent configuration parameter control?",
        "options": {
            "A": "The maximum number of concurrent queries",
            "B": "The maximum number of concurrent scrape requests",
            "C": "The maximum number of concurrent remote_write requests",
            "D": "The maximum number of concurrent alert evaluations"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the percentage of memory used by each process type?",
        "options": {
            "A": "(sum(process_memory_usage_bytes) by (process_type) / sum(node_memory_total_bytes)) * 100",
            "B": "sum(process_memory_usage_bytes) by (process_type) / sum(node_memory_total_bytes) * 100",
            "C": "percent(process_memory_usage_bytes, node_memory_total_bytes) by (process_type)",
            "D": "(process_memory_usage_bytes / node_memory_total_bytes) * 100 by (process_type)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of receiver in an Alertmanager route?",
        "options": {
            "A": "The default receiver for alerts matching this route",
            "B": "The primary receiver for all alerts",
            "C": "The receiver to use for resolved alerts",
            "D": "The receiver to exclude from this route"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of samples that can be stored per time series?",
        "options": {
            "A": "storage.tsdb.max-samples-per-series",
            "B": "tsdb.max-samples-per-series",
            "C": "There is no such parameter",
            "D": "max_samples_per_series"
        },
        "answer": "C"
    },
    {
        "question": "What is the effect of action: labelkeep in a relabel configuration?",
        "options": {
            "A": "Keeps only the specified labels, dropping all others",
            "B": "Keeps targets that have the specified labels",
            "C": "Keeps the original labels after relabeling",
            "D": "Keeps labels with values matching the regex"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function estimates the time until a gauge reaches zero based on current trends?",
        "options": {
            "A": "predict_linear()",
            "B": "time_to_zero()",
            "C": "depletion_time()",
            "D": "gauge_estimate()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the web.external-url configuration in Prometheus?",
        "options": {
            "A": "The external URL used to access Prometheus web interface",
            "B": "The URL of external services to scrape",
            "C": "The URL for remote_write endpoints",
            "D": "The URL of the Alertmanager instance"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type would you use to track the time taken to generate reports, with client-side quantiles?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "D"
    },
    {
        "question": "What does the storage.tsdb.no-lockfile configuration do?",
        "options": {
            "A": "Disables the creation of the TSDB lockfile",
            "B": "Allows multiple Prometheus instances to access the same TSDB",
            "C": "Disables file locking during compaction",
            "D": "Enables read-only access to the TSDB"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the number of instances where disk usage has increased by more than 10GB in the last 24 hours?",
        "options": {
            "A": "count(delta(node_filesystem_used_bytes[24h]) > 10e9)",
            "B": "count(increase(node_filesystem_used_bytes[24h]) > 10e9)",
            "C": "sum(delta(node_filesystem_used_bytes[24h]) > 10e9) by (instance)",
            "D": "count(node_filesystem_used_bytes - (node_filesystem_used_bytes offset 24h) > 10e9)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of equal in an Alertmanager inhibit rule?",
        "options": {
            "A": "Label names that must have identical values in both alerts",
            "B": "Labels that must be present in both alerts",
            "C": "Labels that should be excluded from inhibition checks",
            "D": "Labels that define equality between alert groups"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses OpenStack instances?",
        "options": {
            "A": "openstack_sd_configs",
            "B": "os_sd_configs",
            "C": "openstack_instance_sd_configs",
            "D": "cloud_openstack_sd_configs"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the maximum value of a metric over a rolling 5-minute window?",
        "options": {
            "A": "max_over_time(metric[5m])",
            "B": "rolling_max(metric[5m])",
            "C": "max(metric[5m])",
            "D": "max_rolling(metric[5m])"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of rule_eval_timeout in Prometheus configuration?",
        "options": {
            "A": "Timeout for evaluating recording and alerting rules",
            "B": "Timeout for querying metrics used in rules",
            "C": "Timeout for sending alerts to Alertmanager",
            "D": "Timeout for storing results of rule evaluations"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should you use to track the current temperature of multiple sensors?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the remote_write.queue_config.capacity configuration parameter control?",
        "options": {
            "A": "The maximum number of samples that can be queued for remote_write",
            "B": "The maximum number of concurrent remote_write requests",
            "C": "The maximum size of a remote_write batch",
            "D": "The maximum time samples can stay in the queue"
        },
        "answer": "A"
    },
    {
        "question": "Which query calculates the total number of requests per hour for the last 24 hours?",
        "options": {
            "A": "sum(increase(http_requests_total[1h])) without()",
            "B": "rate(http_requests_total[24h]) * 3600",
            "C": "sum_over_time(http_requests_total[1h:])[24h:1h]",
            "D": "increase(http_requests_total[24h]) / 24"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of continue in an Alertmanager route?",
        "options": {
            "A": "Whether to continue evaluating subsequent routes after a match",
            "B": "Whether to continue sending notifications after a failure",
            "C": "Whether to continue processing alerts after a resolution",
            "D": "Whether to continue grouping alerts after the initial notification"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of targets that can be scraped per job?",
        "options": {
            "A": "scrape.max_targets",
            "B": "max_targets_per_job",
            "C": "scrape.target_limit",
            "D": "There is no such parameter"
        },
        "answer": "D"
    },
    {
        "question": "What is the effect of action: replace_all in a relabel configuration?",
        "options": {
            "A": "Replaces all label values with a new value",
            "B": "This is not a valid relabel action",
            "C": "Replaces all labels with a single new label",
            "D": "Replaces all target addresses with a new value"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the cumulative distribution function from a histogram?",
        "options": {
            "A": "histogram_cdf()",
            "B": "cdf(histogram_quantile(...))",
            "C": "sum(rate(histogram_bucket[5m])) by (le) / sum(rate(histogram_count[5m]))",
            "D": "distribution_cdf()"
        },
        "answer": "C"
    }
]

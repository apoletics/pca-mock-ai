[
    {
        "question": "What is the primary purpose of Prometheus' exposition format?",
        "options": {
            "A": "To store metrics in a relational database",
            "B": "To standardize how metrics are exposed by targets",
            "C": "To encrypt metric data during transmission",
            "D": "To aggregate metrics across multiple instances"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the per-second rate of a counter metric?",
        "options": {
            "A": "avg()",
            "B": "rate()",
            "C": "sum()",
            "D": "increase()"
        },
        "answer": "B"
    },
    {
        "question": "What does the `relabel_configs` section in Prometheus configuration control?",
        "options": {
            "A": "Alert routing rules",
            "B": "Metric storage retention",
            "C": "Target selection and label manipulation",
            "D": "Dashboard visualization settings"
        },
        "answer": "C"
    },
    {
        "question": "Which component handles alert routing and deduplication in Prometheus?",
        "options": {
            "A": "Prometheus server",
            "B": "Alertmanager",
            "C": "Grafana",
            "D": "Pushgateway"
        },
        "answer": "B"
    },
    {
        "question": "What is the default web port for Prometheus?",
        "options": {
            "A": "9090",
            "B": "9093",
            "C": "8080",
            "D": "8088"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type tracks the current value of a resource (e.g., CPU usage)?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "How does Prometheus primarily collect metrics from targets?",
        "options": {
            "A": "Push-based model",
            "B": "Pull-based model",
            "C": "Hybrid push-pull model",
            "D": "File-based ingestion"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `scrape_interval` parameter in Prometheus configuration?",
        "options": {
            "A": "Defines how often Prometheus scrapes targets",
            "B": "Sets the retention period for metrics",
            "C": "Configures alerting evaluation frequency",
            "D": "Controls service discovery refresh rate"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate quantiles from histogram metrics?",
        "options": {
            "A": "histogram_quantile()",
            "B": "quantile()",
            "C": "rate_quantile()",
            "D": "percentile()"
        },
        "answer": "A"
    },
    {
        "question": "What does the `repeat_interval` parameter in Alertmanager configuration control?",
        "options": {
            "A": "How often alerts are re-evaluated",
            "B": "The delay before sending repeated alerts for the same condition",
            "C": "The time to wait before grouping alerts",
            "D": "The maximum time to retain alert history"
        },
        "answer": "B"
    },
    {
        "question": "Which tool helps applications expose Prometheus-compatible metrics?",
        "options": {
            "A": "Node exporter",
            "B": "Client libraries",
            "C": "Blackbox exporter",
            "D": "Grafana"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the Pushgateway in Prometheus?",
        "options": {
            "A": "To store long-term metric data",
            "B": "To allow short-lived jobs to push metrics",
            "C": "To visualize metrics in dashboards",
            "D": "To route alerts to external systems"
        },
        "answer": "B"
    },
    {
        "question": "Which of the following is NOT a valid Prometheus metric type?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Timer",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What is the role of `service discovery` in Prometheus?",
        "options": {
            "A": "Automatically detect and add targets for scraping",
            "B": "Route alerts to appropriate teams",
            "C": "Aggregate metrics across multiple instances",
            "D": "Store metric data in a distributed database"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL operator is used to perform arithmetic operations on time series?",
        "options": {
            "A": "Logical operators",
            "B": "Binary operators",
            "C": "Aggregation operators",
            "D": "Regex operators"
        },
        "answer": "B"
    },
    {
        "question": "What does the `group_wait` parameter in Alertmanager configuration control?",
        "options": {
            "A": "The time to wait before grouping alerts",
            "B": "The delay before sending repeated alerts",
            "C": "The maximum time to retain alert history",
            "D": "The time to wait before resolving alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is commonly used to collect host-level metrics (CPU, memory, disk)?",
        "options": {
            "A": "Node exporter",
            "B": "MySQL exporter",
            "C": "Redis exporter",
            "D": "Blackbox exporter"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `metric_relabel_configs` in Prometheus?",
        "options": {
            "A": "Modify labels after metrics are scraped",
            "B": "Filter targets before scraping",
            "C": "Configure alerting rules",
            "D": "Aggregate metrics across instances"
        },
        "answer": "A"
    },
    {
        "question": "Which of the following is a valid Prometheus metric name?",
        "options": {
            "A": "http_requests_total",
            "B": "HTTP.Requests.Total",
            "C": "HttpRequestCount",
            "D": "requests_total"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertmanager_config` section in Prometheus configuration specify?",
        "options": {
            "A": "Alerting rules",
            "B": "Alertmanager endpoint URL",
            "C": "Scraping targets",
            "D": "Dashboard templates"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the derivative of a gauge metric over time?",
        "options": {
            "A": "deriv()",
            "B": "delta()",
            "C": "rate()",
            "D": "increase()"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use case for the Pushgateway?",
        "options": {
            "A": "Long-running services with static endpoints",
            "B": "Short-lived jobs that cannot be scraped",
            "C": "High-throughput streaming data",
            "D": "Real-time log aggregation"
        },
        "answer": "B"
    },
    {
        "question": "Which of the following is part of Prometheus' data model?",
        "options": {
            "A": "Tables and rows",
            "B": "Metrics and labels",
            "C": "Documents and fields",
            "D": "Queues and topics"
        },
        "answer": "B"
    },
    {
        "question": "What does the `external_labels` section in Prometheus configuration add to all metrics?",
        "options": {
            "A": "Static labels for identifying the Prometheus instance",
            "B": "Dynamic labels based on target metadata",
            "C": "Alerting severity labels",
            "D": "Dashboard visualization labels"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to filter time series based on label values?",
        "options": {
            "A": "label_replace()",
            "B": "label_values()",
            "C": "label_join()",
            "D": "label_match()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `rule_files` section in Prometheus configuration?",
        "options": {
            "A": "Define alerting rules",
            "B": "Configure service discovery",
            "C": "Set up remote write endpoints",
            "D": "Manage dashboard templates"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is best suited for tracking the number of HTTP requests over time?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "A"
    },
    {
        "question": "What does the `scrape_timeout` parameter in Prometheus configuration control?",
        "options": {
            "A": "The maximum time to wait for a scrape request",
            "B": "The interval between scrapes",
            "C": "The retention period for metrics",
            "D": "The number of retries for failed scrapes"
        },
        "answer": "A"
    },
    {
        "question": "Which component is responsible for storing Prometheus metrics?",
        "options": {
            "A": "Alertmanager",
            "B": "Prometheus server",
            "C": "Grafana",
            "D": "Remote write endpoint"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `honor_labels` parameter in Prometheus configuration?",
        "options": {
            "A": "Use labels from the target instead of Prometheus' default labels",
            "B": "Aggregate metrics across all labels",
            "C": "Filter targets based on label values",
            "D": "Add static labels to all metrics"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the sum of a metric over a time range?",
        "options": {
            "A": "sum_over_time()",
            "B": "avg_over_time()",
            "C": "max_over_time()",
            "D": "min_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary function of the `remote_write` section in Prometheus configuration?",
        "options": {
            "A": "Send metrics to external storage systems",
            "B": "Receive metrics from remote sources",
            "C": "Route alerts to external services",
            "D": "Configure service discovery for remote targets"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor Kubernetes resources like pods and services?",
        "options": {
            "A": "Kube-state-metrics",
            "B": "Node exporter",
            "C": "Prometheus operator",
            "D": "Blackbox exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `evaluation_interval` parameter in Prometheus configuration control?",
        "options": {
            "A": "How often alerting rules are evaluated",
            "B": "The interval between scrapes",
            "C": "The retention period for metrics",
            "D": "The time to wait before resolving alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL operator is used to combine metrics from different time series?",
        "options": {
            "A": "Logical OR",
            "B": "Arithmetic addition",
            "C": "Set operations",
            "D": "Regex matching"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `alert` section in Prometheus rules files?",
        "options": {
            "A": "Define alerting conditions",
            "B": "Configure alert routing",
            "C": "Aggregate metrics for dashboards",
            "D": "Set up service discovery"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is used to track the distribution of request durations?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What does the `source_labels` parameter in `relabel_configs` specify?",
        "options": {
            "A": "Labels to modify or filter",
            "B": "Labels to add to the target",
            "C": "Labels to remove from the target",
            "D": "Labels to use for grouping alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which component is used to visualize Prometheus metrics in dashboards?",
        "options": {
            "A": "Alertmanager",
            "B": "Grafana",
            "C": "Prometheus server",
            "D": "Pushgateway"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `job_name` parameter in Prometheus scrape configurations?",
        "options": {
            "A": "Group targets into logical jobs",
            "B": "Define the name of the Prometheus instance",
            "C": "Set the retention period for metrics",
            "D": "Configure alerting rules"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the rate of change over a sliding window?",
        "options": {
            "A": "rate()",
            "B": "increase()",
            "C": "delta()",
            "D": "deriv()"
        },
        "answer": "A"
    },
    {
        "question": "What does the `action` parameter in `relabel_configs` control?",
        "options": {
            "A": "The type of relabeling operation to perform",
            "B": "The labels to modify",
            "C": "The regex pattern to match",
            "D": "The replacement value for labels"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor MySQL databases?",
        "options": {
            "A": "MySQL exporter",
            "B": "Node exporter",
            "C": "Redis exporter",
            "D": "Blackbox exporter"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `external_url` parameter in Prometheus configuration?",
        "options": {
            "A": "Define the public URL for Prometheus",
            "B": "Configure remote write endpoints",
            "C": "Set up service discovery",
            "D": "Route alerts to external services"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to filter time series based on label existence?",
        "options": {
            "A": "label_values()",
            "B": "label_names()",
            "C": "count_values()",
            "D": "count_by()"
        },
        "answer": "B"
    },
    {
        "question": "What does the `for` parameter in alerting rules specify?",
        "options": {
            "A": "The duration an alert must be active before firing",
            "B": "The interval between alert evaluations",
            "C": "The retention period for alert history",
            "D": "The severity level of the alert"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type provides pre-aggregated summaries of data distributions?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "D"
    },
    {
        "question": "What is the purpose of the `honor_timestamps` parameter in Prometheus configuration?",
        "options": {
            "A": "Use timestamps from the target instead of Prometheus' server time",
            "B": "Aggregate metrics across all timestamps",
            "C": "Filter targets based on timestamp ranges",
            "D": "Add static timestamps to all metrics"
        },
        "answer": "A"
    },
    {
        "question": "Which component is used to discover targets in a Kubernetes cluster?",
        "options": {
            "A": "Kubernetes service discovery",
            "B": "Consul service discovery",
            "C": "Zookeeper service discovery",
            "D": "DNS service discovery"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `query_range` API endpoint in Prometheus?",
        "options": {
            "A": "Query metrics over a time range",
            "B": "Query instant metrics",
            "C": "Configure alerting rules",
            "D": "Send metrics to remote storage"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the minimum value over a time range?",
        "options": {
            "A": "min_over_time()",
            "B": "max_over_time()",
            "C": "avg_over_time()",
            "D": "sum_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertname` label in Prometheus alerts uniquely identify?",
        "options": {
            "A": "The alerting rule",
            "B": "The target instance",
            "C": "The severity level",
            "D": "The alert state"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is used to track the number of active database connections?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `sample_limit` parameter in Prometheus configuration?",
        "options": {
            "A": "Limit the number of samples per query",
            "B": "Set the retention period for metrics",
            "C": "Configure service discovery refresh rate",
            "D": "Control the number of concurrent scrapes"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the difference between two time series?",
        "options": {
            "A": "sub()",
            "B": "add()",
            "C": "mul()",
            "D": "div()"
        },
        "answer": "A"
    },
    {
        "question": "What does the `state` field in Alertmanager notifications indicate?",
        "options": {
            "A": "The alert's current state (firing or resolved)",
            "B": "The severity level of the alert",
            "C": "The target instance affected by the alert",
            "D": "The alerting rule name"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is used to track the number of items in a queue over time?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `alertmanager_notifier` component in Prometheus?",
        "options": {
            "A": "Send alerts to Alertmanager",
            "B": "Aggregate metrics for dashboards",
            "C": "Store metrics in remote storage",
            "D": "Discover targets for scraping"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the rate of change over a specific time window?",
        "options": {
            "A": "rate()",
            "B": "increase()",
            "C": "delta()",
            "D": "deriv()"
        },
        "answer": "B"
    },
    {
        "question": "What does the `status` field in Prometheus alerts indicate?",
        "options": {
            "A": "The alert's current state (firing or pending)",
            "B": "The severity level of the alert",
            "C": "The target instance affected by the alert",
            "D": "The alerting rule name"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is used to track the latency of HTTP requests?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `alertmanager_config` section in Prometheus rules files?",
        "options": {
            "A": "Configure Alertmanager endpoints",
            "B": "Define alerting rules",
            "C": "Aggregate metrics for dashboards",
            "D": "Set up service discovery"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls how long Prometheus retains metric data?",
        "options": {
            "A": "scrape_interval",
            "B": "retention_time",
            "C": "storage.tsdb.retention.time",
            "D": "metric_ttl"
        },
        "answer": "C"
    },
    {
        "question": "What does the `label_replace()` function in PromQL do?",
        "options": {
            "A": "Removes labels from time series",
            "B": "Creates new labels based on existing label values",
            "C": "Filters time series by label values",
            "D": "Counts distinct label values"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism uses DNS records to find targets?",
        "options": {
            "A": "Kubernetes SD",
            "B": "DNS SD",
            "C": "File SD",
            "D": "Consul SD"
        },
        "answer": "B"
    },
    {
        "question": "What is the default port for the Node Exporter?",
        "options": {
            "A": "9100",
            "B": "9090",
            "C": "9093",
            "D": "8080"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager configuration parameter defines where to send notifications?",
        "options": {
            "A": "route",
            "B": "receivers",
            "C": "group_by",
            "D": "inhibit_rules"
        },
        "answer": "B"
    },
    {
        "question": "What type of metric should you use to track the number of failed login attempts?",
        "options": {
            "A": "Gauge",
            "B": "Counter",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the number of unique label values for a metric?",
        "options": {
            "A": "count_values()",
            "B": "label_count()",
            "C": "unique_labels()",
            "D": "distinct_count()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `inhibit_rules` in Alertmanager?",
        "options": {
            "A": "To prevent certain alerts from firing if other alerts are active",
            "B": "To group similar alerts together",
            "C": "To route alerts to specific receivers",
            "D": "To set the severity level of alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery method uses a static configuration file?",
        "options": {
            "A": "Kubernetes SD",
            "B": "File SD",
            "C": "EC2 SD",
            "D": "DNS SD"
        },
        "answer": "B"
    },
    {
        "question": "What does the `quantile()` function in PromQL calculate?",
        "options": {
            "A": "The average value of a metric",
            "B": "A specific percentile of a metric's distribution",
            "C": "The sum of values over time",
            "D": "The rate of change of a counter"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter controls how often Prometheus evaluates alerting rules?",
        "options": {
            "A": "evaluation_interval",
            "B": "scrape_interval",
            "C": "alert_interval",
            "D": "rule_interval"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary purpose of the Blackbox exporter?",
        "options": {
            "A": "To monitor host-level metrics",
            "B": "To perform active checks on network endpoints",
            "C": "To export database metrics",
            "D": "To collect container metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL operator is used for pattern matching on label values?",
        "options": {
            "A": "=~",
            "B": "==",
            "C": "=!",
            "D": "!="
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `group_by` parameter in Alertmanager?",
        "options": {
            "A": "To group alerts by time of occurrence",
            "B": "To group alerts by severity",
            "C": "To group alerts by label values",
            "D": "To group alerts by receiver"
        },
        "answer": "C"
    },
    {
        "question": "Which metric type would you use to track the current temperature of a server?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the `rate()` function do when applied to a gauge metric?",
        "options": {
            "A": "Calculates the per-second rate of change",
            "B": "Returns an error",
            "C": "Treats the gauge as a counter",
            "D": "Calculates the average value"
        },
        "answer": "A"
    },
    {
        "question": "Which configuration option enables Prometheus to federate metrics from other Prometheus instances?",
        "options": {
            "A": "federation_config",
            "B": "remote_read",
            "C": "scrape_configs with honor_labels",
            "D": "federate_from"
        },
        "answer": "C"
    },
    {
        "question": "What is the default port for Alertmanager?",
        "options": {
            "A": "9090",
            "B": "9093",
            "C": "9094",
            "D": "9100"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function combines multiple time series into one by adding their values?",
        "options": {
            "A": "merge()",
            "B": "sum()",
            "C": "concat()",
            "D": "add()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `keep_dropped_targets` parameter in Prometheus?",
        "options": {
            "A": "To retain metrics from targets that have been dropped",
            "B": "To keep track of targets that failed relabeling",
            "C": "To store configuration history of dropped targets",
            "D": "To prevent targets from being removed"
        },
        "answer": "B"
    },
    {
        "question": "Which exporter would you use to monitor Redis instances?",
        "options": {
            "A": "Node exporter",
            "B": "Redis exporter",
            "C": "MySQL exporter",
            "D": "Blackbox exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `offset` modifier do in PromQL?",
        "options": {
            "A": "Shifts the time range of the query backwards",
            "B": "Filters results by time",
            "C": "Changes the evaluation interval",
            "D": "Offsets label values"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager parameter sets the maximum time to wait before sending a notification?",
        "options": {
            "A": "group_wait",
            "B": "group_interval",
            "C": "repeat_interval",
            "D": "send_delay"
        },
        "answer": "A"
    },
    {
        "question": "What is the recommended naming convention for counter metrics?",
        "options": {
            "A": "*-counter",
            "B": "count_*",
            "C": "*_total",
            "D": "total_*"
        },
        "answer": "C"
    },
    {
        "question": "Which PromQL function calculates the number of time series matching a selector?",
        "options": {
            "A": "count()",
            "B": "count_series()",
            "C": "series_count()",
            "D": "num_series()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `remote_read` configuration in Prometheus?",
        "options": {
            "A": "To send metrics to external storage",
            "B": "To read metrics from external storage",
            "C": "To replicate configuration to other instances",
            "D": "To federate with other Prometheus servers"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism is appropriate for AWS EC2 instances?",
        "options": {
            "A": "Kubernetes SD",
            "B": "EC2 SD",
            "C": "File SD",
            "D": "DNS SD"
        },
        "answer": "B"
    },
    {
        "question": "What does the `delta()` function calculate in PromQL?",
        "options": {
            "A": "The difference between the first and last value in a range",
            "B": "The average value over a range",
            "C": "The rate of change per second",
            "D": "The sum of values over a range"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager receiver type sends notifications via email?",
        "options": {
            "A": "slack_configs",
            "B": "email_configs",
            "C": "pagerduty_configs",
            "D": "webhook_configs"
        },
        "answer": "B"
    },
    {
        "question": "What is cardinality in the context of Prometheus metrics?",
        "options": {
            "A": "The number of metrics stored",
            "B": "The number of unique label combinations",
            "C": "The size of each metric sample",
            "D": "The frequency of metric collection"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function is used to calculate the average value over a time range?",
        "options": {
            "A": "avg()",
            "B": "mean()",
            "C": "avg_over_time()",
            "D": "mean_over_time()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `prometheus_operator_` metrics?",
        "options": {
            "A": "To monitor the Prometheus Operator itself",
            "B": "To monitor Kubernetes clusters",
            "C": "To monitor application performance",
            "D": "To monitor Alertmanager instances"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter in a scrape configuration defines the HTTP path to scrape metrics from?",
        "options": {
            "A": "path",
            "B": "metrics_path",
            "C": "scrape_path",
            "D": "target_path"
        },
        "answer": "B"
    },
    {
        "question": "What does the `label_join()` function do in PromQL?",
        "options": {
            "A": "Combines multiple labels into a single label",
            "B": "Splits a label into multiple labels",
            "C": "Filters time series by label combinations",
            "D": "Counts the number of labels"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager configuration parameter determines how often to send notifications for active alerts?",
        "options": {
            "A": "group_wait",
            "B": "group_interval",
            "C": "repeat_interval",
            "D": "notification_interval"
        },
        "answer": "C"
    },
    {
        "question": "What type of metric would you use to track request latency distributions?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    },
    {
        "question": "Which PromQL operator performs a logical NOT on a label matcher?",
        "options": {
            "A": "!",
            "B": "NOT",
            "C": "!~",
            "D": "^"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `scrape_configs` section in Prometheus configuration?",
        "options": {
            "A": "To define alerting rules",
            "B": "To configure which targets to scrape for metrics",
            "C": "To set up remote storage",
            "D": "To configure Alertmanager integration"
        },
        "answer": "B"
    },
    {
        "question": "Which exporter is used to monitor PostgreSQL databases?",
        "options": {
            "A": "MySQL exporter",
            "B": "PostgreSQL exporter",
            "C": "Database exporter",
            "D": "SQL exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `increase()` function calculate in PromQL?",
        "options": {
            "A": "The total increase in a counter over a time range",
            "B": "The per-second rate of increase",
            "C": "The maximum value in a range",
            "D": "The average value in a range"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager parameter defines the root route for alert processing?",
        "options": {
            "A": "route",
            "B": "root_route",
            "C": "default_route",
            "D": "primary_route"
        },
        "answer": "A"
    },
    {
        "question": "What is the recommended way to handle high cardinality labels?",
        "options": {
            "A": "Avoid them when possible",
            "B": "Use them for all labels",
            "C": "Store them as separate metrics",
            "D": "Encrypt them"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the maximum value over a time range?",
        "options": {
            "A": "max()",
            "B": "max_over_time()",
            "C": "peak()",
            "D": "highest()",
            "D": "highest()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `metric_relabel_configs` in a scrape configuration?",
        "options": {
            "A": "To relabel targets before scraping",
            "B": "To relabel metrics after scraping",
            "C": "To configure service discovery",
            "D": "To set alerting thresholds"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism is appropriate for Docker containers?",
        "options": {
            "A": "Docker SD",
            "B": "Kubernetes SD",
            "C": "File SD",
            "D": "EC2 SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `irate()` function do in PromQL?",
        "options": {
            "A": "Calculates an instant rate using the last two samples",
            "B": "Calculates a rate over a longer time period",
            "C": "Calculates the average rate over a range",
            "D": "Calculates the maximum rate in a range"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager receiver type sends notifications to Slack?",
        "options": {
            "A": "email_configs",
            "B": "slack_configs",
            "C": "pagerduty_configs",
            "D": "webhook_configs"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `summary` metric type?",
        "options": {
            "A": "To track cumulative counts",
            "B": "To track current values",
            "C": "To track distributions with pre-calculated quantiles",
            "D": "To track histograms with configurable buckets"
        },
        "answer": "C"
    },
    {
        "question": "Which PromQL operator is used for exact label matching?",
        "options": {
            "A": "=~",
            "B": "!~",
            "C": "=",
            "D": "!="
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.path` configuration parameter?",
        "options": {
            "A": "To set the path for configuration files",
            "B": "To set the path for storing time series data",
            "C": "To set the path for log files",
            "D": "To set the path for alert rules"
        },
        "answer": "B"
    },
    {
        "question": "Which exporter would you use to monitor HTTP endpoints for availability?",
        "options": {
            "A": "Node exporter",
            "B": "Blackbox exporter",
            "C": "HTTP exporter",
            "D": "Web exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `topk()` function do in PromQL?",
        "options": {
            "A": "Returns the top k time series by value",
            "B": "Returns the top k percent of values",
            "C": "Returns the k highest values over time",
            "D": "Returns the k most recent values"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager parameter sets the time to wait before sending a notification for a new group of alerts?",
        "options": {
            "A": "group_wait",
            "B": "group_interval",
            "C": "repeat_interval",
            "D": "group_delay"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `job` label automatically added by Prometheus?",
        "options": {
            "A": "To identify the scrape job that collected the metric",
            "B": "To identify the target instance",
            "C": "To identify the metric type",
            "D": "To identify the severity level"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the standard deviation over a time range?",
        "options": {
            "A": "stddev()",
            "B": "stddev_over_time()",
            "C": "deviation()",
            "D": "variance()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `kubernetes_sd_configs` in Prometheus?",
        "options": {
            "A": "To discover targets in a Kubernetes cluster",
            "B": "To monitor the Prometheus Operator",
            "C": "To configure Kubernetes alerts",
            "D": "To store Kubernetes metrics"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter in a scrape configuration sets the maximum time to wait for a scrape to complete?",
        "options": {
            "A": "scrape_timeout",
            "B": "timeout",
            "C": "scrape_deadline",
            "D": "max_scrape_time"
        },
        "answer": "A"
    },
    {
        "question": "What does the `histogram_quantile()` function require as input?",
        "options": {
            "A": "A counter metric",
            "B": "A gauge metric",
            "C": "A histogram metric",
            "D": "A summary metric"
        },
        "answer": "C"
    },
    {
        "question": "Which Alertmanager receiver type sends notifications to PagerDuty?",
        "options": {
            "A": "email_configs",
            "B": "slack_configs",
            "C": "pagerduty_configs",
            "D": "webhook_configs"
        },
        "answer": "C"
    },
    {
        "question": "What is the recommended approach for metric naming?",
        "options": {
            "A": "Use short abbreviations",
            "B": "Be descriptive and include units where applicable",
            "C": "Use camelCase",
            "D": "Include the metric type in the name"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function is used to calculate the number of unique values for a label?",
        "options": {
            "A": "count_values()",
            "B": "unique_count()",
            "C": "label_count()",
            "D": "distinct_values()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `alert_relabel_configs` in Prometheus?",
        "options": {
            "A": "To relabel alerts before sending to Alertmanager",
            "B": "To relabel metrics used in alerts",
            "C": "To configure alerting rules",
            "D": "To set alert severity levels"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Consul for service discovery?",
        "options": {
            "A": "Consul SD",
            "B": "Kubernetes SD",
            "C": "DNS SD",
            "D": "File SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `vector()` function do in PromQL?",
        "options": {
            "A": "Converts a scalar to a vector",
            "B": "Converts a vector to a scalar",
            "C": "Filters a vector by time",
            "D": "Aggregates a vector"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the number of samples Prometheus keeps in memory?",
        "options": {
            "A": "storage.tsdb.memory_samples",
            "B": "memory_limit",
            "C": "sample_cache_size",
            "D": "storage.memory_limit"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the JMX exporter?",
        "options": {
            "A": "To monitor Java applications via JMX",
            "B": "To monitor web applications",
            "C": "To monitor network devices",
            "D": "To monitor container orchestration platforms"
        },
        "answer": "A"
    },
    {
        "question": "What is the default size of a TSDB block in Prometheus?",
        "options": {
            "A": "1 hour",
            "B": "2 hours",
            "C": "6 hours",
            "D": "12 hours"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function checks for missing time series?",
        "options": {
            "A": "missing()",
            "B": "absent()",
            "C": "empty()",
            "D": "null()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the SNMP exporter?",
        "options": {
            "A": "To monitor Java applications",
            "B": "To collect metrics from SNMP-enabled devices",
            "C": "To track database performance",
            "D": "To monitor Kubernetes clusters"
        },
        "answer": "B"
    },
    {
        "question": "Which Alertmanager state indicates an alert condition is met but hasn't been firing long enough?",
        "options": {
            "A": "Pending",
            "B": "Firing",
            "C": "Resolved",
            "D": "Inactive"
        },
        "answer": "A"
    },
    {
        "question": "What does the `sort()` function do in PromQL?",
        "options": {
            "A": "Sorts time series by timestamp",
            "B": "Sorts time series by label values",
            "C": "Sorts time series by sample value",
            "D": "Sorts alerts by severity"
        },
        "answer": "C"
    },
    {
        "question": "Which configuration parameter controls the maximum number of samples per time series?",
        "options": {
            "A": "storage.tsdb.max_samples",
            "B": "storage.tsdb.sample_limit",
            "C": "tsdb.max_samples_per_series",
            "D": "storage.max_samples_per_series"
        },
        "answer": "B"
    },
    {
        "question": "What is the primary use case for the `changes()` function in PromQL?",
        "options": {
            "A": "Counting label changes over time",
            "B": "Calculating the number of value changes in a gauge",
            "C": "Measuring rate of counter increments",
            "D": "Tracking alert state transitions"
        },
        "answer": "B"
    },
    {
        "question": "Which service discovery mechanism is used for Azure virtual machines?",
        "options": {
            "A": "Azure SD",
            "B": "EC2 SD",
            "C": "Cloud SD",
            "D": "VM SD"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `alertmanager.url` parameter in Prometheus?",
        "options": {
            "A": "Defines where Prometheus sends alerts",
            "B": "Configures Alertmanager's web interface URL",
            "C": "Sets the API endpoint for querying alerts",
            "D": "Specifies the Alertmanager replication target"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type should be used to track the number of active user sessions?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "B"
    },
    {
        "question": "What does the `quantile` parameter in a Summary metric define?",
        "options": {
            "A": "The number of buckets to use",
            "B": "The percentile thresholds to pre-calculate",
            "C": "The maximum sample age",
            "D": "The aggregation interval"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter controls the frequency of TSDB compaction?",
        "options": {
            "A": "storage.tsdb.compaction.frequency",
            "B": "tsdb.compact.interval",
            "C": "storage.compaction.frequency",
            "D": "tsdb.compaction.frequency"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `label_replace()` function's `replacement` parameter?",
        "options": {
            "A": "The label to remove",
            "B": "The new label name",
            "C": "The pattern to match",
            "D": "The value to assign to the new label"
        },
        "answer": "D"
    },
    {
        "question": "Which exporter is used to monitor network devices via SNMP?",
        "options": {
            "A": "Network exporter",
            "B": "SNMP exporter",
            "C": "Device exporter",
            "D": "Interface exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is a 'child route' in Alertmanager configuration?",
        "options": {
            "A": "A route that inherits properties from a parent route",
            "B": "A route for low-severity alerts",
            "C": "A route that overrides all parent configurations",
            "D": "A route for resolved alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function returns the earliest timestamp in a range vector?",
        "options": {
            "A": "first_over_time()",
            "B": "earliest()",
            "C": "start_time()",
            "D": "min_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of setting `honor_labels: true` in a scrape configuration?",
        "options": {
            "A": "Preserves target labels over Prometheus-generated labels",
            "B": "Overwrites target labels with Prometheus-generated ones",
            "C": "Encrypts sensitive label values",
            "D": "Automatically adds environment labels"
        },
        "answer": "A"
    },
    {
        "question": "Which function calculates the ratio between two time series in PromQL?",
        "options": {
            "A": "ratio()",
            "B": "div()",
            "C": "proportion()",
            "D": "fraction()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `prometheus_tsdb_head_samples` metric?",
        "options": {
            "A": "Counting samples in the active TSDB block",
            "B": "Measuring scrape latency",
            "C": "Tracking alert evaluation times",
            "D": "Monitoring storage disk usage"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery method uses OpenStack instances?",
        "options": {
            "A": "OpenStack SD",
            "B": "Cloud SD",
            "C": "Instance SD",
            "D": "OpenStack Discovery"
        },
        "answer": "A"
    },
    {
        "question": "What does the `resolve_timeout` parameter in Alertmanager control?",
        "options": {
            "A": "Time to wait before marking an alert as resolved",
            "B": "Timeout for alert notifications",
            "C": "Delay before sending resolve notifications",
            "D": "Time to retain resolved alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the sum of squares over time?",
        "options": {
            "A": "sum_squares()",
            "B": "squares_sum_over_time()",
            "C": "sum2_over_time()",
            "D": "sum_squares_over_time()"
        },
        "answer": "D"
    },
    {
        "question": "What is the default compression algorithm for TSDB blocks?",
        "options": {
            "A": "GZIP",
            "B": "Snappy",
            "C": "LZ4",
            "D": "ZSTD"
        },
        "answer": "C"
    },
    {
        "question": "Which parameter configures the maximum time a scrape can be queued?",
        "options": {
            "A": "scrape_queue_timeout",
            "B": "queue_timeout",
            "C": "scrape.queue_timeout",
            "D": "scrape_queue_max_time"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `holt_winters()` function in PromQL?",
        "options": {
            "A": "Forecasting metric values",
            "B": "Calculating moving averages",
            "C": "Detecting anomalies",
            "D": "Smoothing label values"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor Windows services and performance counters?",
        "options": {
            "A": "Windows exporter",
            "B": "WMI exporter",
            "C": "Win32 exporter",
            "D": "Microsoft exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `send_resolved: false` in Alertmanager receiver configuration?",
        "options": {
            "A": "Does not send notifications when alerts resolve",
            "B": "Prevents resolving alerts automatically",
            "C": "Sends resolve notifications with a delay",
            "D": "Marks resolved alerts as inactive immediately"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL operator is used for set intersection of two vectors?",
        "options": {
            "A": "and",
            "B": "or",
            "C": "unless",
            "D": "intersect"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.wal-compression` parameter?",
        "options": {
            "A": "Enables compression of write-ahead logs",
            "B": "Compresses historical TSDB blocks",
            "C": "Reduces network bandwidth for remote writes",
            "D": "Compresses alert notifications"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses DNS SRV records?",
        "options": {
            "A": "DNS SD (SRV)",
            "B": "SRV Discovery",
            "C": "DNS-SRV SD",
            "D": "Service SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertmanager_alerts_received_total` metric track?",
        "options": {
            "A": "Total alerts sent to Alertmanager",
            "B": "Total alerts received by Alertmanager",
            "C": "Total alerts fired by Prometheus",
            "D": "Total resolved alerts"
        },
        "answer": "B"
    },
    {
        "question": "Which metric type should be used to track the number of failed database transactions?",
        "options": {
            "A": "Gauge",
            "B": "Counter",
            "C": "Summary",
            "D": "Histogram"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `quantile_over_time()` function?",
        "options": {
            "A": "Calculates quantiles across label dimensions",
            "B": "Computes quantiles for a single time series over time",
            "C": "Aggregates quantiles from histograms",
            "D": "Compares quantiles between different metrics"
        },
        "answer": "B"
    },
    {
        "question": "Which parameter controls the maximum number of concurrent scrapes?",
        "options": {
            "A": "scrape_concurrency",
            "B": "concurrent_scrapes",
            "C": "max_concurrent_scrapes",
            "D": "scrape.max_concurrency"
        },
        "answer": "B"
    },
    {
        "question": "What is the primary use of the `last_over_time()` function?",
        "options": {
            "A": "Gets the most recent value in a range vector",
            "B": "Finds the last occurrence of a label value",
            "C": "Identifies the last alert in a group",
            "D": "Retrieves the final sample before a target went down"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor Elasticsearch clusters?",
        "options": {
            "A": "ES exporter",
            "B": "Elastic exporter",
            "C": "Search exporter",
            "D": "Elasticsearch exporter"
        },
        "answer": "D"
    },
    {
        "question": "What is a 'mute time interval' in Alertmanager?",
        "options": {
            "A": "A time range when alerts are not sent",
            "B": "A delay before sending new alerts",
            "C": "A period after which alerts are automatically resolved",
            "D": "A timeout for notification delivery"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the standard deviation of a vector?",
        "options": {
            "A": "stddev()",
            "B": "stddev_over_time()",
            "C": "deviation()",
            "D": "variance()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.partition-range` parameter?",
        "options": {
            "A": "Splits TSDB data into partitions by time range",
            "B": "Defines the range of label values to index",
            "C": "Sets the time range for block compaction",
            "D": "Configures the retention period for partitions"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery method uses Docker Swarm?",
        "options": {
            "A": "Docker Swarm SD",
            "B": "Swarm SD",
            "C": "Container SD",
            "D": "Orchestrator SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_target_interval_length_seconds` metric measure?",
        "options": {
            "A": "Actual scrape interval for targets",
            "B": "Configured scrape interval",
            "C": "Time between service discovery refreshes",
            "D": "Alert evaluation interval"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the Alertmanager cluster peers?",
        "options": {
            "A": "cluster.peers",
            "B": "alertmanager.cluster",
            "C": "cluster.members",
            "D": "peer_list"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `sort_desc()` function in PromQL?",
        "options": {
            "A": "Sorts time series by label values descending",
            "B": "Sorts time series by sample values descending",
            "C": "Sorts alerts by firing time descending",
            "D": "Sorts metrics by name descending"
        },
        "answer": "B"
    },
    {
        "question": "Which configuration controls the maximum size of the TSDB write-ahead log?",
        "options": {
            "A": "storage.tsdb.wal-size",
            "B": "storage.wal.max-size",
            "C": "tsdb.wal.max_bytes",
            "D": "storage.tsdb.wal-max-size"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `metric_relabel_configs` with `action: drop`?",
        "options": {
            "A": "Drops the entire target from scraping",
            "B": "Drops specific metrics after scraping",
            "C": "Drops labels from metrics",
            "D": "Drops alerts matching the condition"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL function calculates the exponential moving average?",
        "options": {
            "A": "ema()",
            "B": "exponential_avg()",
            "C": "avg_ema_over_time()",
            "D": "holt_winters()"
        },
        "answer": "D"
    },
    {
        "question": "Which exporter is used to monitor MongoDB databases?",
        "options": {
            "A": "Mongo exporter",
            "B": "MongoDB exporter",
            "C": "NoSQL exporter",
            "D": "DocumentDB exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of `group_interval` in Alertmanager?",
        "options": {
            "A": "Time to wait before grouping new alerts",
            "B": "Time between sending notifications for the same alert group",
            "C": "Time to retain grouped alerts",
            "D": "Time to wait before resolving grouped alerts"
        },
        "answer": "B"
    },
    {
        "question": "Which PromQL operator returns time series from the left vector not present in the right vector?",
        "options": {
            "A": "and",
            "B": "or",
            "C": "unless",
            "D": "except"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.allow-overlapping-blocks` parameter?",
        "options": {
            "A": "Allows importing backfilled data",
            "B": "Enables block compaction",
            "C": "Permits concurrent writes to TSDB",
            "D": "Allows overlapping scrape intervals"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Consul Connect?",
        "options": {
            "A": "Consul Connect SD",
            "B": "Service Mesh SD",
            "C": "Connect SD",
            "D": "Mesh Discovery"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_rule_evaluation_duration_seconds` metric track?",
        "options": {
            "A": "Time taken to evaluate alerting rules",
            "B": "Time between rule evaluations",
            "C": "Total time spent processing alerts",
            "D": "Duration of metric storage"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter sets the maximum number of alerts that can be active at once?",
        "options": {
            "A": "alertmanager.max_alerts",
            "B": "alert.max_active",
            "C": "rule.alert.max_active",
            "D": "alertmanager.alert.active_limit"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `label_replace()` function's `regex` parameter?",
        "options": {
            "A": "The regular expression to match label values",
            "B": "The replacement pattern for labels",
            "C": "The label to apply the regex to",
            "D": "The new label name to create"
        },
        "answer": "A"
    },
    {
        "question": "Which configuration parameter controls TSDB block retention size?",
        "options": {
            "A": "storage.tsdb.retention.size",
            "B": "storage.tsdb.max_size",
            "C": "tsdb.retention.bytes",
            "D": "storage.max_retention_size"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `vector(0)` expression in PromQL?",
        "options": {
            "A": "To create a zero vector for comparison",
            "B": "To reset counter values",
            "C": "To represent missing time series",
            "D": "To zero out gauge values"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Redis instances?",
        "options": {
            "A": "Cache exporter",
            "B": "Redis exporter",
            "C": "Key-value exporter",
            "D": "In-memory exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `inhibit_rules` with `equal: ['alertname']`?",
        "options": {
            "A": "Inhibits alerts with the same name",
            "B": "Allows alerts with matching names",
            "C": "Inhibits alerts with different names",
            "D": "Groups alerts by name before inhibition"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function returns the number of samples in a range vector?",
        "options": {
            "A": "count_samples()",
            "B": "samples_count()",
            "C": "count_over_time()",
            "D": "sample_count_over_time()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.no-lockfile` parameter?",
        "options": {
            "A": "Disables the TSDB lock file for read-only access",
            "B": "Enables concurrent writes to TSDB",
            "C": "Prevents TSDB compaction",
            "D": "Allows multiple Prometheus instances to share storage"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery method uses DNS A records?",
        "options": {
            "A": "DNS SD (A records)",
            "B": "ARecord SD",
            "C": "DNS-A Discovery",
            "D": "Host SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertmanager_notification_failures_total` metric measure?",
        "options": {
            "A": "Number of failed notification attempts",
            "B": "Number of suppressed notifications",
            "C": "Number of resolved alerts not notified",
            "D": "Number of duplicate notifications"
        },
        "answer": "A"
    },
    {
        "question": "Which metric type is best for tracking API response time distributions?",
        "options": {
            "A": "Counter",
            "B": "Gauge",
            "C": "Histogram",
            "D": "Summary"
        },
        "answer": "C"
    }
    {
        "question": "Which service discovery mechanism is used for Google Cloud Platform instances?",
        "options": {
            "A": "GCP SD",
            "B": "Cloud SD",
            "C": "GCE SD",
            "D": "Google SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_tsdb_compaction_duration_seconds` metric measure?",
        "options": {
            "A": "Time taken to compact TSDB blocks",
            "B": "Interval between compactions",
            "C": "Size reduction from compaction",
            "D": "Number of blocks compacted"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the variance of values over time?",
        "options": {
            "A": "variance()",
            "B": "var_over_time()",
            "C": "variance_over_time()",
            "D": "var()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `queue_config` in Alertmanager?",
        "options": {
            "A": "Configures notification batching",
            "B": "Sets up retry queues for failed notifications",
            "C": "Defines alert grouping order",
            "D": "Controls alert resolution timing"
        },
        "answer": "B"
    },
    {
        "question": "Which exporter is used to monitor RabbitMQ brokers?",
        "options": {
            "A": "Message broker exporter",
            "B": "RabbitMQ exporter",
            "C": "Queue exporter",
            "D": "AMQP exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `action: keep` in `relabel_configs`?",
        "options": {
            "A": "Keeps only targets matching the relabel condition",
            "B": "Preserves all labels on the target",
            "C": "Retains metrics after scraping",
            "D": "Maintains alert state for matching alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function returns the standard variance of a vector?",
        "options": {
            "A": "stdvar()",
            "B": "variance()",
            "C": "stddev_squared()",
            "D": "var()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.wal-segment-size` parameter?",
        "options": {
            "A": "Sets the size of each write-ahead log segment",
            "B": "Defines the maximum WAL total size",
            "C": "Controls WAL compression ratio",
            "D": "Configures WAL retention period"
        },
        "answer": "A"
    },
    {
        "question": "Which Alertmanager parameter defines the maximum number of alerts in a single notification?",
        "options": {
            "A": "group_max_alerts",
            "B": "max_alerts_per_notification",
            "C": "notification.alert_limit",
            "D": "group.alert_count_max"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `label_values()` function in PromQL?",
        "options": {
            "A": "To get all unique values for a specific label",
            "B": "To filter time series by label values",
            "C": "To replace label values with new ones",
            "D": "To count distinct label values"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Kafka clusters?",
        "options": {
            "A": "Stream exporter",
            "B": "Kafka exporter",
            "C": "Broker exporter",
            "D": "Topic exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `storage.tsdb.min-block-duration` parameter control?",
        "options": {
            "A": "Minimum time before a block is compacted",
            "B": "Smallest block size created by TSDB",
            "C": "Minimum duration for which blocks are retained",
            "D": "Time between block rotations"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL operator returns time series that exist in either of two vectors?",
        "options": {
            "A": "or",
            "B": "and",
            "C": "union",
            "D": "either"
        },
        "answer": "A"
    },
    {
        "question": "What is a 'route tree' in Alertmanager configuration?",
        "options": {
            "A": "A hierarchical structure for alert routing",
            "B": "A list of receivers in priority order",
            "C": "A timeline of alert notifications",
            "D": "A mapping of alert names to severity"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the maximum number of TSDB blocks to keep?",
        "options": {
            "A": "storage.tsdb.max_blocks",
            "B": "storage.tsdb.retention.blocks",
            "C": "tsdb.max_blocks_to_keep",
            "D": "storage.blocks.max_count"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `holt_winters()` function's `factor` parameter?",
        "options": {
            "A": "Controls smoothing strength for the level",
            "B": "Sets the prediction horizon",
            "C": "Defines the confidence interval",
            "D": "Adjusts for seasonal patterns"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor NGINX web servers?",
        "options": {
            "A": "Web server exporter",
            "B": "HTTP exporter",
            "C": "NGINX exporter",
            "D": "Proxy exporter"
        },
        "answer": "C"
    },
    {
        "question": "What does the `alertmanager_cluster_members` metric track?",
        "options": {
            "A": "Number of Alertmanager instances in the cluster",
            "B": "Number of alerts processed by the cluster",
            "C": "Time since cluster last rebalanced",
            "D": "Number of failed cluster communications"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the sum of absolute differences over time?",
        "options": {
            "A": "sum_abs_diff_over_time()",
            "B": "abs_sum_over_time()",
            "C": "sum_abs_over_time()",
            "D": "abs_diff_sum_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `group_by: ['...']` with an empty list in Alertmanager?",
        "options": {
            "A": "Groups all alerts into a single notification",
            "B": "Disables grouping entirely",
            "C": "Inherits grouping from parent route",
            "D": "Groups alerts by timestamp"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Kubernetes pod annotations?",
        "options": {
            "A": "Kubernetes Pod SD",
            "B": "Annotation SD",
            "C": "K8s Annotation SD",
            "D": "Pod Annotation Discovery"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `prometheus_target_scrape_pool_sync_duration_seconds` metric?",
        "options": {
            "A": "Time to sync scrape pools with service discovery",
            "B": "Duration of individual scrapes",
            "C": "Interval between scrape pool refreshes",
            "D": "Time to resolve target IPs"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the median over time?",
        "options": {
            "A": "median_over_time()",
            "B": "quantile_over_time(0.5, ...)",
            "C": "mid_over_time()",
            "D": "50th_percentile_over_time()"
        },
        "answer": "B"
    },
    {
        "question": "What does the `storage.tsdb.wal-fsync-delay` parameter control?",
        "options": {
            "A": "Delay before syncing WAL to disk",
            "B": "Interval between WAL fsyncs",
            "C": "Timeout for WAL write operations",
            "D": "Buffer size before WAL fsync"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Ceph storage clusters?",
        "options": {
            "A": "Storage exporter",
            "B": "Ceph exporter",
            "C": "Distributed storage exporter",
            "D": "RADOS exporter"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of `matchers` in Alertmanager route configuration?",
        "options": {
            "A": "Define which alerts match the route",
            "B": "Filter labels from alerts",
            "C": "Set severity levels for alerts",
            "D": "Specify notification channels"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function returns the number of unique label combinations across time series?",
        "options": {
            "A": "count({__name__=~".+"})",
            "B": "label_cardinality()",
            "C": "unique_series_count()",
            "D": "series_count()"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `storage.tsdb.wal-enabled: false`?",
        "options": {
            "A": "Disables write-ahead logging (risk of data loss)",
            "B": "Enables in-memory only storage",
            "C": "Uses a different storage engine",
            "D": "Increases write performance by 50%"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of alerts processed per evaluation in Prometheus?",
        "options": {
            "A": "alert.max_processed_per_eval",
            "B": "rule.alert.process_limit",
            "C": "promql.alert.process_limit",
            "D": "alert.evaluation.limit"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `label_join()` function's `separator` parameter?",
        "options": {
            "A": "String to separate joined label values",
            "B": "Regex pattern to split labels",
            "C": "Character to replace in labels",
            "D": "Delimiter for output formatting"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor Docker daemon metrics?",
        "options": {
            "A": "Container exporter",
            "B": "Docker daemon exporter",
            "C": "Docker exporter",
            "D": "Containerd exporter"
        },
        "answer": "C"
    },
    {
        "question": "What does the `alertmanager_notification_latency_seconds` metric measure?",
        "options": {
            "A": "Time from alert receipt to notification sent",
            "B": "Delay between alert firing and resolution",
            "C": "Time to batch alerts before notification",
            "D": "Latency between Prometheus and Alertmanager"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the 95th percentile over a range vector?",
        "options": {
            "A": "quantile_over_time(0.95, ...)",
            "B": "percentile_over_time(95, ...)",
            "C": "p95_over_time()",
            "D": "histogram_quantile(0.95, ...)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `storage.tsdb.wal-compression-level` parameter?",
        "options": {
            "A": "Sets compression strength for WAL files",
            "B": "Defines number of compression threads",
            "C": "Controls compression ratio vs speed",
            "D": "Specifies minimum size for compression"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses AWS ECS tasks?",
        "options": {
            "A": "ECS SD",
            "B": "AWS ECS SD",
            "C": "Container SD",
            "D": "EC2 Task SD"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `action: labelmap` in `relabel_configs`?",
        "options": {
            "A": "Maps labels using a regex pattern",
            "B": "Copies all labels to a new namespace",
            "C": "Renames labels based on a static map",
            "D": "Removes labels not in the map"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors PostgreSQL databases?",
        "options": {
            "A": "Postgres exporter",
            "B": "PostgreSQL exporter",
            "C": "SQL exporter",
            "D": "Relational DB exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `prometheus_alertmanager_http_requests_total` metric track?",
        "options": {
            "A": "HTTP requests from Prometheus to Alertmanager",
            "B": "API requests to Prometheus' alert endpoints",
            "C": "Alertmanager requests to Prometheus",
            "D": "HTTP errors in alert notifications"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function is used to calculate the sum of absolute values over time?",
        "options": {
            "A": "sum_abs_over_time()",
            "B": "abs_sum_over_time()",
            "C": "sum_absolute_over_time()",
            "D": "absolute_sum_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `cluster.advertise-address` in Alertmanager configuration?",
        "options": {
            "A": "Address used to advertise to other cluster members",
            "B": "Public URL for Alertmanager UI",
            "C": "Endpoint for Prometheus to send alerts",
            "D": "IP for health checks"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the maximum number of label namespaces in Prometheus?",
        "options": {
            "A": "storage.tsdb.max_label_namespaces",
            "B": "label.namespace.max_count",
            "C": "tsdb.label_namespace.limit",
            "D": "max_label_namespaces"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `vector(1)` expression in PromQL?",
        "options": {
            "A": "To normalize ratios to 1.0",
            "B": "To increment counter values by 1",
            "C": "To create a baseline for comparisons",
            "D": "To enable vector matching"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter is used to monitor Apache HTTP servers?",
        "options": {
            "A": "Apache exporter",
            "B": "HTTPD exporter",
            "C": "Web server exporter",
            "D": "Apache HTTP exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertmanager_config_hash` metric represent?",
        "options": {
            "A": "A hash of the current Alertmanager configuration",
            "B": "Checksum of alert rules",
            "C": "Hash of notification templates",
            "D": "Cluster configuration version"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the mode (most frequent value) over time?",
        "options": {
            "A": "mode_over_time()",
            "B": "most_frequent_over_time()",
            "C": "frequency_over_time()",
            "D": "topk_over_time(1, ...)"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `storage.tsdb.wal-segment-cleanup-age`?",
        "options": {
            "A": "Age after which WAL segments are deleted",
            "B": "Time to retain WAL segments for recovery",
            "C": "Interval between WAL cleanup runs",
            "D": "Minimum age for WAL compaction"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Marathon for container orchestration?",
        "options": {
            "A": "Marathon SD",
            "B": "Mesos SD",
            "C": "Container Orchestrator SD",
            "D": "Marathon Discovery"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `receiver: 'null'` in an Alertmanager route?",
        "options": {
            "A": "Drops alerts matching the route",
            "B": "Sends alerts to a default receiver",
            "C": "Queues alerts for later processing",
            "D": "Logs alerts but doesn't send notifications"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of concurrent rule evaluations?",
        "options": {
            "A": "rule.evaluation.concurrent",
            "B": "concurrent_rule_evaluations",
            "C": "rule.max_concurrent_evals",
            "D": "evaluation.concurrent.limit"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `label_replace()` function's `target_label` parameter?",
        "options": {
            "A": "Name of the new label to create",
            "B": "Label to replace with new value",
            "C": "Label to apply regex to",
            "D": "Default value if regex doesn't match"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Redis Cluster metrics?",
        "options": {
            "A": "Redis Cluster exporter",
            "B": "Redis Cluster Monitor",
            "C": "Distributed Redis exporter",
            "D": "Redis exporter (with cluster mode)"
        },
        "answer": "D"
    },
    {
        "question": "What does the `prometheus_tsdb_head_series` metric track?",
        "options": {
            "A": "Number of active time series in memory",
            "B": "Total series stored on disk",
            "C": "Series added in the last evaluation",
            "D": "Series dropped due to limits"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the cumulative distribution function over time?",
        "options": {
            "A": "cdf_over_time()",
            "B": "cumulative_distribution_over_time()",
            "C": "distribution_cumulative_over_time()",
            "D": "quantile_cumulative_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `cluster.listen-address` in Alertmanager?",
        "options": {
            "A": "Address to listen for cluster communications",
            "B": "Public address for UI access",
            "C": "Endpoint for Prometheus alerts",
            "D": "IP for health check probes"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter sets the maximum label value length in Prometheus?",
        "options": {
            "A": "storage.tsdb.label.value-length-limit",
            "B": "label.value.max_length",
            "C": "tsdb.label_value_length_limit",
            "D": "max_label_value_length"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of `label_replace()` with a negative regex match?",
        "options": {
            "A": "Creating labels for non-matching values",
            "B": "Removing labels that match a pattern",
            "C": "Renaming labels that don't match",
            "D": "Setting default labels when no match occurs"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors GitLab instances?",
        "options": {
            "A": "GitLab exporter",
            "B": "Code repo exporter",
            "C": "Git exporter",
            "D": "SCM exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `alertmanager_silenced_alerts` metric track?",
        "options": {
            "A": "Number of alerts currently silenced",
            "B": "Total alerts silenced since startup",
            "C": "Silences that have expired",
            "D": "Alerts matching active silences"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the geometric mean over time?",
        "options": {
            "A": "geomean_over_time()",
            "B": "geometric_mean_over_time()",
            "C": "geo_mean_over_time()",
            "D": "mean_geometric_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `storage.tsdb.index-cache-size`?",
        "options": {
            "A": "Size of the in-memory index cache",
            "B": "Disk space allocated for indexes",
            "C": "Maximum size of index files",
            "D": "Cache TTL for index entries"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Zookeeper for service registration?",
        "options": {
            "A": "Zookeeper SD",
            "B": "Distributed SD",
            "C": "ZK Discovery",
            "D": "Coordination SD"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `repeat_interval: 1h` in Alertmanager for a firing alert?",
        "options": {
            "A": "Sends a repeat notification every hour until resolved",
            "B": "Waits 1 hour before first notification",
            "C": "Resolves the alert after 1 hour",
            "D": "Groups alerts for 1 hour before sending"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter controls the maximum number of samples per query?",
        "options": {
            "A": "query.max-samples",
            "B": "promql.max_samples",
            "C": "query.sample_limit",
            "D": "max_samples_per_query"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `label_join()` function's `dst_label` parameter?",
        "options": {
            "A": "Name of the new label to create",
            "B": "Label to append joined values to",
            "C": "Source labels to join",
            "D": "Default value if join fails"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors JVM metrics for Java applications?",
        "options": {
            "A": "JVM exporter",
            "B": "Java exporter",
            "C": "JMX exporter",
            "D": "JRE exporter"
        },
        "answer": "C"
    },
    {
        "question": "What does the `prometheus_tsdb_wal_truncations_total` metric track?",
        "options": {
            "A": "Number of times WAL was truncated",
            "B": "Size of WAL truncations",
            "C": "Time spent truncating WAL",
            "D": "WAL segments marked for truncation"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for DigitalOcean Droplets?",
        "options": {
            "A": "DigitalOcean SD",
            "B": "DO Droplet SD",
            "C": "Cloud Droplet SD",
            "D": "Ocean SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_tsdb_index_version` metric indicate?",
        "options": {
            "A": "Version of the TSDB index format in use",
            "B": "Number of index updates performed",
            "C": "Size of the index on disk",
            "D": "Time since last index compaction"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the skewness of values over time?",
        "options": {
            "A": "skew()",
            "B": "skew_over_time()",
            "C": "skewness()",
            "D": "skewness_over_time()"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of `alertmanager_silence_creation_total` metric?",
        "options": {
            "A": "Total number of silences created",
            "B": "Active silences currently applied",
            "C": "Silences that have expired",
            "D": "Failed silence creation attempts"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Envoy proxies?",
        "options": {
            "A": "Proxy exporter",
            "B": "Envoy exporter",
            "C": "Service mesh exporter",
            "D": "Envoy proxy exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does `storage.tsdb.block-reprocess-interval` control?",
        "options": {
            "A": "Interval for reprocessing old blocks",
            "B": "Time between block rotations",
            "C": "Frequency of block verification",
            "D": "Delay before blocks are compacted"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the kurtosis over time?",
        "options": {
            "A": "kurtosis()",
            "B": "kurtosis_over_time()",
            "C": "kurt()",
            "D": "kurt_over_time()"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `matchers: [{name: 'severity', value: 'critical'}]` in an Alertmanager route?",
        "options": {
            "A": "Routes only critical severity alerts",
            "B": "Sets severity to critical for all alerts",
            "C": "Excludes critical alerts from this route",
            "D": "Groups critical alerts separately"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for OpenShift resources?",
        "options": {
            "A": "OpenShift SD",
            "B": "Kubernetes SD with OpenShift annotations",
            "C": "OCP SD",
            "D": "Red Hat SD"
        },
        "answer": "B"
    },
    {
        "question": "What does the `prometheus_tsdb_head_chunk_range_seconds` metric measure?",
        "options": {
            "A": "Time range covered by in-memory chunks",
            "B": "Size of chunks in the head block",
            "C": "Interval between chunk rotations",
            "D": "Compression ratio of chunks"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the cumulative sum over time?",
        "options": {
            "A": "cumsum_over_time()",
            "B": "cumulative_sum_over_time()",
            "C": "sum_cumulative_over_time()",
            "D": "running_sum_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `templates` in Alertmanager configuration?",
        "options": {
            "A": "Customize notification message formats",
            "B": "Define alert routing logic",
            "C": "Configure service discovery templates",
            "D": "Set up metric relabeling patterns"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Consul service mesh?",
        "options": {
            "A": "Consul exporter",
            "B": "Service mesh exporter",
            "C": "Consul mesh exporter",
            "D": "HashiCorp exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does `storage.tsdb.index-version` configure?",
        "options": {
            "A": "TSDB index format version",
            "B": "Frequency of index updates",
            "C": "Index compression algorithm",
            "D": "Maximum size of the index"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function identifies the most frequent label value in a vector?",
        "options": {
            "A": "mode()",
            "B": "most_frequent()",
            "C": "topk(1, count_values(...))",
            "D": "frequency()"
        },
        "answer": "C"
    },
    {
        "question": "What is a 'silence' in Alertmanager?",
        "options": {
            "A": "A temporary suppression of specific alerts",
            "B": "A permanent filter for unwanted alerts",
            "C": "A delay in notification delivery",
            "D": "A debug mode for alert evaluation"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses DNS TXT records for metadata?",
        "options": {
            "A": "DNS SD with TXT records",
            "B": "TXT SD",
            "C": "Metadata DNS SD",
            "D": "Text record SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_target_metadata_cache_duration_seconds` metric track?",
        "options": {
            "A": "Time target metadata is cached",
            "B": "Duration to fetch target metadata",
            "C": "Interval between metadata refreshes",
            "D": "Metadata storage size"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the exponential moving average with a specified window?",
        "options": {
            "A": "ema_over_time()",
            "B": "exponential_avg_over_time()",
            "C": "holt_winters() with trend=0",
            "D": "moving_avg_exponential_over_time()"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of `alertmanager_cluster_gossip_messages_total`?",
        "options": {
            "A": "Total gossip messages between cluster members",
            "B": "Alerts shared between cluster instances",
            "C": "Configuration updates propagated via gossip",
            "D": "Failed cluster communication attempts"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the TSDB block wal buffer size?",
        "options": {
            "A": "storage.tsdb.wal-buffer-size",
            "B": "tsdb.wal.buffer.size",
            "C": "storage.wal.buffer.size",
            "D": "tsdb.block.wal.buffer"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `label_regex()` function in PromQL?",
        "options": {
            "A": "Filtering time series by label regex",
            "B": "Extracting substrings from labels into new labels",
            "C": "Counting labels matching a regex",
            "D": "Replacing label values with regex patterns"
        },
        "answer": "B"
    },
    {
        "question": "Which exporter monitors Envoy proxy metrics?",
        "options": {
            "A": "Proxy exporter",
            "B": "Envoy exporter",
            "C": "Service mesh exporter",
            "D": "Istio exporter"
        },
        "answer": "B"
    },
    {
        "question": "What does the `alertmanager_silence_duration_seconds` metric track?",
        "options": {
            "A": "Duration of active silences",
            "B": "Time since last silence was created",
            "C": "Total time alerts have been silenced",
            "D": "Minimum silence duration configured"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the sum of squares of differences from the mean over time?",
        "options": {
            "A": "sum_sq_diff_over_time()",
            "B": "variance_sum_over_time()",
            "C": "squared_deviation_sum_over_time()",
            "D": "mean_sq_diff_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `cluster.gossip-interval` in Alertmanager?",
        "options": {
            "A": "Interval between gossip messages",
            "B": "Delay before syncing configuration",
            "C": "Frequency of cluster health checks",
            "D": "Time to wait for cluster consensus"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for DigitalOcean Kubernetes clusters?",
        "options": {
            "A": "DigitalOcean Kubernetes SD",
            "B": "Kubernetes SD with DigitalOcean provider",
            "C": "DOKS SD",
            "D": "Cloud Kubernetes SD"
        },
        "answer": "B"
    },
    {
        "question": "What does the `prometheus_tsdb_head_max_chunk_age_seconds` metric measure?",
        "options": {
            "A": "Maximum age of chunks in the head block",
            "B": "Time until chunks are flushed to disk",
            "C": "Lifespan of compacted blocks",
            "D": "Retention period for in-memory chunks"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the interquartile range over time?",
        "options": {
            "A": "iqr_over_time()",
            "B": "quantile_range_over_time()",
            "C": "interquartile_over_time()",
            "D": "range_quantile_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `alertmanager_notification_template_files`?",
        "options": {
            "A": "Paths to notification template files",
            "B": "Templates for alert rule definitions",
            "C": "Service discovery configuration templates",
            "D": "Label relabeling pattern files"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Kafka Connect clusters?",
        "options": {
            "A": "Kafka Connect exporter",
            "B": "Connect exporter",
            "C": "Kafka connector exporter",
            "D": "Stream processor exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does `storage.tsdb.memory-chunks` configure?",
        "options": {
            "A": "Maximum number of in-memory chunks",
            "B": "Memory allocated to chunk storage",
            "C": "Chunk compression level",
            "D": "Number of chunks per block"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function identifies the longest consecutive increase in a counter?",
        "options": {
            "A": "max_increase_streak()",
            "B": "longest_increase_over_time()",
            "C": "increase_streak_length()",
            "D": "consecutive_increases_over_time()"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `cluster.tls_config` in Alertmanager?",
        "options": {
            "A": "Enables TLS for cluster communication",
            "B": "Encrypts alert notifications",
            "C": "Secures the Alertmanager UI with TLS",
            "D": "Verifies Prometheus server certificates"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for Linode instances?",
        "options": {
            "A": "Linode SD",
            "B": "Cloud SD with Linode provider",
            "C": "Linode Instance SD",
            "D": "VPS SD"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_tsdb_read_requests_total` metric track?",
        "options": {
            "A": "Total TSDB read operations",
            "B": "PromQL query requests",
            "C": "Remote read requests",
            "D": "Block decompression operations"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the number of non-null values over time?",
        "options": {
            "A": "count_non_null_over_time()",
            "B": "non_null_count_over_time()",
            "C": "not_null_over_time()",
            "D": "valid_samples_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `alertmanager_silence_matchers`?",
        "options": {
            "A": "Label matchers defining which alerts to silence",
            "B": "Silences that match current alerts",
            "C": "Number of alerts matched by silences",
            "D": "Silences that have expired but still match alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the TSDB index page size?",
        "options": {
            "A": "storage.tsdb.index-page-size",
            "B": "tsdb.index.page.size",
            "C": "storage.index.page.size",
            "D": "tsdb.page.size.index"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of the `label_count()` function in PromQL?",
        "options": {
            "A": "Counting the number of labels on a time series",
            "B": "Counting time series with a specific label",
            "C": "Counting distinct values for a label",
            "D": "Counting label matches for a regex"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Caddy web servers?",
        "options": {
            "A": "Caddy exporter",
            "B": "Web server exporter",
            "C": "Caddy metrics exporter",
            "D": "HTTP server exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_tsdb_compaction_objects_removed_total` metric track?",
        "options": {
            "A": "Number of objects removed during compaction",
            "B": "Blocks deleted after compaction",
            "C": "Bytes freed by compaction",
            "D": "Failed compaction attempts"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the mean absolute deviation over time?",
        "options": {
            "A": "mad_over_time()",
            "B": "mean_abs_deviation_over_time()",
            "C": "abs_deviation_mean_over_time()",
            "D": "average_deviation_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `alertmanager_notification_configs`?",
        "options": {
            "A": "Defining receiver-specific notification settings",
            "B": "Configuring global notification defaults",
            "C": "Setting up alert routing rules",
            "D": "Specifying silence conditions"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism uses Nomad for job discovery?",
        "options": {
            "A": "Nomad SD",
            "B": "Job SD",
            "C": "HashiCorp SD",
            "D": "Orchestrator SD"
        },
        "answer": "A"
    },
    {
        "question": "What does `storage.tsdb.wal-fsync-interval` configure?",
        "options": {
            "A": "Maximum time between WAL fsyncs",
            "B": "Minimum time between WAL fsyncs",
            "C": "Timeout for WAL fsync operations",
            "D": "Interval between WAL segment rotations"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the sum of absolute differences from the median over time?",
        "options": {
            "A": "mad_over_time()",
            "B": "median_abs_deviation_over_time()",
            "C": "abs_diff_median_over_time()",
            "D": "sum_abs_median_diff_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `alertmanager_cluster_peer_timeout`?",
        "options": {
            "A": "Timeout for cluster peer communication",
            "B": "Time to wait for peer acknowledgment",
            "C": "Interval between peer health checks",
            "D": "Time to retain peer information after failure"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the maximum number of concurrent TSDB compactions?",
        "options": {
            "A": "storage.tsdb.max-concurrent-compactions",
            "B": "tsdb.compaction.concurrent.max",
            "C": "storage.compaction.concurrent.limit",
            "D": "max_concurrent_compactions"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of `label_prefix()` in PromQL?",
        "options": {
            "A": "Adding a prefix to label names",
            "B": "Filtering labels by prefix",
            "C": "Extracting prefixes from label values",
            "D": "Counting labels with a specific prefix"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Traefik reverse proxies?",
        "options": {
            "A": "Traefik exporter",
            "B": "Proxy exporter",
            "C": "Reverse proxy exporter",
            "D": "Ingress exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_target_scrape_series_added` metric track?",
        "options": {
            "A": "New time series added from scrapes",
            "B": "Total series scraped per target",
            "C": "Series removed after scraping",
            "D": "Duplicate series dropped during scraping"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the cumulative maximum over time?",
        "options": {
            "A": "cummax_over_time()",
            "B": "cumulative_max_over_time()",
            "C": "max_cumulative_over_time()",
            "D": "running_max_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of `alertmanager_silence_start_time`?",
        "options": {
            "A": "Start timestamp of active silences",
            "B": "Time when silence was created",
            "C": "Duration since silence became active",
            "D": "Scheduled start time for future silences"
        },
        "answer": "A"
    },
    {
        "question": "Which service discovery mechanism is used for Packet (Equinix Metal) instances?",
        "options": {
            "A": "Packet SD",
            "B": "Equinix SD",
            "C": "Metal SD",
            "D": "Cloud Instance SD"
        },
        "answer": "A"
    },
    {
        "question": "What does `storage.tsdb.index-cache-compression` configure?",
        "options": {
            "A": "Enables compression for index cache",
            "B": "Sets compression level for index files",
            "C": "Configures cache size for compressed indexes",
            "D": "Disables compression for in-memory indexes"
        },
        "answer": "A"
    },
    {
        "question": "Which PromQL function calculates the cumulative minimum over time?",
        "options": {
            "A": "cummin_over_time()",
            "B": "cumulative_min_over_time()",
            "C": "min_cumulative_over_time()",
            "D": "running_min_over_time()"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `alertmanager_cluster_peer_sync_interval`?",
        "options": {
            "A": "Interval for syncing state between cluster peers",
            "B": "Time to wait for full cluster sync",
            "C": "Frequency of configuration checks",
            "D": "Delay before syncing new alerts"
        },
        "answer": "A"
    },
    {
        "question": "Which parameter configures the TSDB block write concurrency?",
        "options": {
            "A": "storage.tsdb.write-concurrency",
            "B": "tsdb.block.write.concurrency",
            "C": "storage.write.concurrency",
            "D": "tsdb.write.concurrent.limit"
        },
        "answer": "A"
    },
    {
        "question": "What is the primary use of `label_suffix()` in PromQL?",
        "options": {
            "A": "Adding a suffix to label names",
            "B": "Filtering labels by suffix",
            "C": "Extracting suffixes from label values",
            "D": "Renaming labels with a suffix"
        },
        "answer": "A"
    },
    {
        "question": "Which exporter monitors Nginx Ingress controllers?",
        "options": {
            "A": "Nginx Ingress exporter",
            "B": "Ingress controller exporter",
            "C": "Kubernetes Ingress exporter",
            "D": "NGINX controller exporter"
        },
        "answer": "A"
    },
    {
        "question": "What does the `prometheus_tsdb_wal_writes_total` metric track?",
        "options": {
            "A": "Total number of WAL write operations",
            "B": "Bytes written to WAL",
            "C": "WAL segments created",
            "D": "WAL write errors"
        },
        "answer": "A"
    }
]
